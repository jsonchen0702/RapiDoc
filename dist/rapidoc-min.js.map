{"version":3,"file":"rapidoc-min.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/lit-html/lib/modify-template.js","webpack:///./node_modules/lit-html/lib/shady-render.js","webpack:///./node_modules/lit-element/lib/decorators.js","webpack:///./node_modules/lit-element/lit-element.js","webpack:///./node_modules/lit-html/lib/template.js","webpack:///./node_modules/lit-html/lib/parts.js","webpack:///./node_modules/lit-html/lib/part.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/lit-html/lib/default-template-processor.js","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./node_modules/lit-html/lib/dom.js","webpack:///./node_modules/lit-html/lib/template-result.js","webpack:///./node_modules/lit-html/lib/template-factory.js","webpack:///./node_modules/lit-html/lib/directive.js","webpack:///./node_modules/lit-html/lib/render.js","webpack:///./node_modules/lit-html/lib/template-instance.js","webpack:///./node_modules/lit-html/directives/unsafe-html.js","webpack:///./src/styles/vars.js","webpack:///./src/components/json-tree.js","webpack:///./src/components/schema-tree.js","webpack:///./src/styles/table-styles.js","webpack:///./src/styles/flex-styles.js","webpack:///./src/styles/input-styles.js","webpack:///./src/styles/font-styles.js","webpack:///./src/styles/common-styles.js","webpack:///./src/utils/common-utils.js","webpack:///./src/components/api-request.js","webpack:///./src/components/api-response.js","webpack:///./src/components/end-point.js","webpack:///./src/components/end-points.js","webpack:///./src/rapidoc.js"],"sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n \tfunction hotDisposeChunk(chunkId) {\n \t\tdelete installedChunks[chunkId];\n \t}\n \tvar parentHotUpdateCallback = window[\"webpackHotUpdate\"];\n \twindow[\"webpackHotUpdate\"] = // eslint-disable-next-line no-unused-vars\n \tfunction webpackHotUpdateCallback(chunkId, moreModules) {\n \t\thotAddUpdateChunk(chunkId, moreModules);\n \t\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\n \t} ;\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadUpdateChunk(chunkId) {\n \t\tvar script = document.createElement(\"script\");\n \t\tscript.charset = \"utf-8\";\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\";\n \t\tif (null) script.crossOrigin = null;\n \t\tdocument.head.appendChild(script);\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadManifest(requestTimeout) {\n \t\trequestTimeout = requestTimeout || 10000;\n \t\treturn new Promise(function(resolve, reject) {\n \t\t\tif (typeof XMLHttpRequest === \"undefined\") {\n \t\t\t\treturn reject(new Error(\"No browser support\"));\n \t\t\t}\n \t\t\ttry {\n \t\t\t\tvar request = new XMLHttpRequest();\n \t\t\t\tvar requestPath = __webpack_require__.p + \"\" + hotCurrentHash + \".hot-update.json\";\n \t\t\t\trequest.open(\"GET\", requestPath, true);\n \t\t\t\trequest.timeout = requestTimeout;\n \t\t\t\trequest.send(null);\n \t\t\t} catch (err) {\n \t\t\t\treturn reject(err);\n \t\t\t}\n \t\t\trequest.onreadystatechange = function() {\n \t\t\t\tif (request.readyState !== 4) return;\n \t\t\t\tif (request.status === 0) {\n \t\t\t\t\t// timeout\n \t\t\t\t\treject(\n \t\t\t\t\t\tnew Error(\"Manifest request to \" + requestPath + \" timed out.\")\n \t\t\t\t\t);\n \t\t\t\t} else if (request.status === 404) {\n \t\t\t\t\t// no update available\n \t\t\t\t\tresolve();\n \t\t\t\t} else if (request.status !== 200 && request.status !== 304) {\n \t\t\t\t\t// other failure\n \t\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\n \t\t\t\t} else {\n \t\t\t\t\t// success\n \t\t\t\t\ttry {\n \t\t\t\t\t\tvar update = JSON.parse(request.responseText);\n \t\t\t\t\t} catch (e) {\n \t\t\t\t\t\treject(e);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\tresolve(update);\n \t\t\t\t}\n \t\t\t};\n \t\t});\n \t}\n\n \tvar hotApplyOnUpdate = true;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentHash = \"7ce004ebf642cb2332dd\";\n \tvar hotRequestTimeout = 10000;\n \tvar hotCurrentModuleData = {};\n \tvar hotCurrentChildModule;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParents = [];\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParentsTemp = [];\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateRequire(moduleId) {\n \t\tvar me = installedModules[moduleId];\n \t\tif (!me) return __webpack_require__;\n \t\tvar fn = function(request) {\n \t\t\tif (me.hot.active) {\n \t\t\t\tif (installedModules[request]) {\n \t\t\t\t\tif (installedModules[request].parents.indexOf(moduleId) === -1) {\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\thotCurrentParents = [moduleId];\n \t\t\t\t\thotCurrentChildModule = request;\n \t\t\t\t}\n \t\t\t\tif (me.children.indexOf(request) === -1) {\n \t\t\t\t\tme.children.push(request);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconsole.warn(\n \t\t\t\t\t\"[HMR] unexpected require(\" +\n \t\t\t\t\t\trequest +\n \t\t\t\t\t\t\") from disposed module \" +\n \t\t\t\t\t\tmoduleId\n \t\t\t\t);\n \t\t\t\thotCurrentParents = [];\n \t\t\t}\n \t\t\treturn __webpack_require__(request);\n \t\t};\n \t\tvar ObjectFactory = function ObjectFactory(name) {\n \t\t\treturn {\n \t\t\t\tconfigurable: true,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: function() {\n \t\t\t\t\treturn __webpack_require__[name];\n \t\t\t\t},\n \t\t\t\tset: function(value) {\n \t\t\t\t\t__webpack_require__[name] = value;\n \t\t\t\t}\n \t\t\t};\n \t\t};\n \t\tfor (var name in __webpack_require__) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\n \t\t\t\tname !== \"e\" &&\n \t\t\t\tname !== \"t\"\n \t\t\t) {\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\n \t\t\t}\n \t\t}\n \t\tfn.e = function(chunkId) {\n \t\t\tif (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n \t\t\thotChunksLoading++;\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\n \t\t\t\tfinishChunkLoading();\n \t\t\t\tthrow err;\n \t\t\t});\n\n \t\t\tfunction finishChunkLoading() {\n \t\t\t\thotChunksLoading--;\n \t\t\t\tif (hotStatus === \"prepare\") {\n \t\t\t\t\tif (!hotWaitingFilesMap[chunkId]) {\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t\t\t}\n \t\t\t\t\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n \t\t\t\t\t\thotUpdateDownloaded();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\tfn.t = function(value, mode) {\n \t\t\tif (mode & 1) value = fn(value);\n \t\t\treturn __webpack_require__.t(value, mode & ~1);\n \t\t};\n \t\treturn fn;\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateModule(moduleId) {\n \t\tvar hot = {\n \t\t\t// private stuff\n \t\t\t_acceptedDependencies: {},\n \t\t\t_declinedDependencies: {},\n \t\t\t_selfAccepted: false,\n \t\t\t_selfDeclined: false,\n \t\t\t_disposeHandlers: [],\n \t\t\t_main: hotCurrentChildModule !== moduleId,\n\n \t\t\t// Module API\n \t\t\tactive: true,\n \t\t\taccept: function(dep, callback) {\n \t\t\t\tif (dep === undefined) hot._selfAccepted = true;\n \t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n \t\t\t\telse hot._acceptedDependencies[dep] = callback || function() {};\n \t\t\t},\n \t\t\tdecline: function(dep) {\n \t\t\t\tif (dep === undefined) hot._selfDeclined = true;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n \t\t\t\telse hot._declinedDependencies[dep] = true;\n \t\t\t},\n \t\t\tdispose: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\taddDisposeHandler: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\tremoveDisposeHandler: function(callback) {\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n \t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t// Management API\n \t\t\tcheck: hotCheck,\n \t\t\tapply: hotApply,\n \t\t\tstatus: function(l) {\n \t\t\t\tif (!l) return hotStatus;\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\taddStatusHandler: function(l) {\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\tremoveStatusHandler: function(l) {\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\n \t\t\t\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t//inherit from previous dispose call\n \t\t\tdata: hotCurrentModuleData[moduleId]\n \t\t};\n \t\thotCurrentChildModule = undefined;\n \t\treturn hot;\n \t}\n\n \tvar hotStatusHandlers = [];\n \tvar hotStatus = \"idle\";\n\n \tfunction hotSetStatus(newStatus) {\n \t\thotStatus = newStatus;\n \t\tfor (var i = 0; i < hotStatusHandlers.length; i++)\n \t\t\thotStatusHandlers[i].call(null, newStatus);\n \t}\n\n \t// while downloading\n \tvar hotWaitingFiles = 0;\n \tvar hotChunksLoading = 0;\n \tvar hotWaitingFilesMap = {};\n \tvar hotRequestedFilesMap = {};\n \tvar hotAvailableFilesMap = {};\n \tvar hotDeferred;\n\n \t// The update info\n \tvar hotUpdate, hotUpdateNewHash;\n\n \tfunction toModuleId(id) {\n \t\tvar isNumber = +id + \"\" === id;\n \t\treturn isNumber ? +id : id;\n \t}\n\n \tfunction hotCheck(apply) {\n \t\tif (hotStatus !== \"idle\") {\n \t\t\tthrow new Error(\"check() is only allowed in idle status\");\n \t\t}\n \t\thotApplyOnUpdate = apply;\n \t\thotSetStatus(\"check\");\n \t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n \t\t\tif (!update) {\n \t\t\t\thotSetStatus(\"idle\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\thotRequestedFilesMap = {};\n \t\t\thotWaitingFilesMap = {};\n \t\t\thotAvailableFilesMap = update.c;\n \t\t\thotUpdateNewHash = update.h;\n\n \t\t\thotSetStatus(\"prepare\");\n \t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\thotDeferred = {\n \t\t\t\t\tresolve: resolve,\n \t\t\t\t\treject: reject\n \t\t\t\t};\n \t\t\t});\n \t\t\thotUpdate = {};\n \t\t\tfor(var chunkId in installedChunks)\n \t\t\t// eslint-disable-next-line no-lone-blocks\n \t\t\t{\n \t\t\t\t/*globals chunkId */\n \t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t}\n \t\t\tif (\n \t\t\t\thotStatus === \"prepare\" &&\n \t\t\t\thotChunksLoading === 0 &&\n \t\t\t\thotWaitingFiles === 0\n \t\t\t) {\n \t\t\t\thotUpdateDownloaded();\n \t\t\t}\n \t\t\treturn promise;\n \t\t});\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotAddUpdateChunk(chunkId, moreModules) {\n \t\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n \t\t\treturn;\n \t\thotRequestedFilesMap[chunkId] = false;\n \t\tfor (var moduleId in moreModules) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n \t\t\thotUpdateDownloaded();\n \t\t}\n \t}\n\n \tfunction hotEnsureUpdateChunk(chunkId) {\n \t\tif (!hotAvailableFilesMap[chunkId]) {\n \t\t\thotWaitingFilesMap[chunkId] = true;\n \t\t} else {\n \t\t\thotRequestedFilesMap[chunkId] = true;\n \t\t\thotWaitingFiles++;\n \t\t\thotDownloadUpdateChunk(chunkId);\n \t\t}\n \t}\n\n \tfunction hotUpdateDownloaded() {\n \t\thotSetStatus(\"ready\");\n \t\tvar deferred = hotDeferred;\n \t\thotDeferred = null;\n \t\tif (!deferred) return;\n \t\tif (hotApplyOnUpdate) {\n \t\t\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\n \t\t\t// avoid triggering uncaught exception warning in Chrome.\n \t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n \t\t\tPromise.resolve()\n \t\t\t\t.then(function() {\n \t\t\t\t\treturn hotApply(hotApplyOnUpdate);\n \t\t\t\t})\n \t\t\t\t.then(\n \t\t\t\t\tfunction(result) {\n \t\t\t\t\t\tdeferred.resolve(result);\n \t\t\t\t\t},\n \t\t\t\t\tfunction(err) {\n \t\t\t\t\t\tdeferred.reject(err);\n \t\t\t\t\t}\n \t\t\t\t);\n \t\t} else {\n \t\t\tvar outdatedModules = [];\n \t\t\tfor (var id in hotUpdate) {\n \t\t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\n \t\t\t\t}\n \t\t\t}\n \t\t\tdeferred.resolve(outdatedModules);\n \t\t}\n \t}\n\n \tfunction hotApply(options) {\n \t\tif (hotStatus !== \"ready\")\n \t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n \t\toptions = options || {};\n\n \t\tvar cb;\n \t\tvar i;\n \t\tvar j;\n \t\tvar module;\n \t\tvar moduleId;\n\n \t\tfunction getAffectedStuff(updateModuleId) {\n \t\t\tvar outdatedModules = [updateModuleId];\n \t\t\tvar outdatedDependencies = {};\n\n \t\t\tvar queue = outdatedModules.slice().map(function(id) {\n \t\t\t\treturn {\n \t\t\t\t\tchain: [id],\n \t\t\t\t\tid: id\n \t\t\t\t};\n \t\t\t});\n \t\t\twhile (queue.length > 0) {\n \t\t\t\tvar queueItem = queue.pop();\n \t\t\t\tvar moduleId = queueItem.id;\n \t\t\t\tvar chain = queueItem.chain;\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (!module || module.hot._selfAccepted) continue;\n \t\t\t\tif (module.hot._selfDeclined) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"self-declined\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tif (module.hot._main) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"unaccepted\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n \t\t\t\t\tvar parentId = module.parents[i];\n \t\t\t\t\tvar parent = installedModules[parentId];\n \t\t\t\t\tif (!parent) continue;\n \t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n \t\t\t\t\t\treturn {\n \t\t\t\t\t\t\ttype: \"declined\",\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\tparentId: parentId\n \t\t\t\t\t\t};\n \t\t\t\t\t}\n \t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n \t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n \t\t\t\t\t\tif (!outdatedDependencies[parentId])\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tdelete outdatedDependencies[parentId];\n \t\t\t\t\toutdatedModules.push(parentId);\n \t\t\t\t\tqueue.push({\n \t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\tid: parentId\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n\n \t\t\treturn {\n \t\t\t\ttype: \"accepted\",\n \t\t\t\tmoduleId: updateModuleId,\n \t\t\t\toutdatedModules: outdatedModules,\n \t\t\t\toutdatedDependencies: outdatedDependencies\n \t\t\t};\n \t\t}\n\n \t\tfunction addAllToSet(a, b) {\n \t\t\tfor (var i = 0; i < b.length; i++) {\n \t\t\t\tvar item = b[i];\n \t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n \t\t\t}\n \t\t}\n\n \t\t// at begin all updates modules are outdated\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n \t\tvar outdatedDependencies = {};\n \t\tvar outdatedModules = [];\n \t\tvar appliedUpdate = {};\n\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\n \t\t\tconsole.warn(\n \t\t\t\t\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\"\n \t\t\t);\n \t\t};\n\n \t\tfor (var id in hotUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\tmoduleId = toModuleId(id);\n \t\t\t\t/** @type {TODO} */\n \t\t\t\tvar result;\n \t\t\t\tif (hotUpdate[id]) {\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\n \t\t\t\t} else {\n \t\t\t\t\tresult = {\n \t\t\t\t\t\ttype: \"disposed\",\n \t\t\t\t\t\tmoduleId: id\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\t/** @type {Error|false} */\n \t\t\t\tvar abortError = false;\n \t\t\t\tvar doApply = false;\n \t\t\t\tvar doDispose = false;\n \t\t\t\tvar chainInfo = \"\";\n \t\t\t\tif (result.chain) {\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n \t\t\t\t}\n \t\t\t\tswitch (result.type) {\n \t\t\t\t\tcase \"self-declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\t\" in \" +\n \t\t\t\t\t\t\t\t\tresult.parentId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"unaccepted\":\n \t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n \t\t\t\t\t\tif (!options.ignoreUnaccepted)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"accepted\":\n \t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n \t\t\t\t\t\tdoApply = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"disposed\":\n \t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n \t\t\t\t\t\tdoDispose = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n \t\t\t\t}\n \t\t\t\tif (abortError) {\n \t\t\t\t\thotSetStatus(\"abort\");\n \t\t\t\t\treturn Promise.reject(abortError);\n \t\t\t\t}\n \t\t\t\tif (doApply) {\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n \t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n \t\t\t\t\t\tif (\n \t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n \t\t\t\t\t\t\t\tresult.outdatedDependencies,\n \t\t\t\t\t\t\t\tmoduleId\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t) {\n \t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n \t\t\t\t\t\t\taddAllToSet(\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n \t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (doDispose) {\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Store self accepted outdated modules to require them later by the module system\n \t\tvar outdatedSelfAcceptedModules = [];\n \t\tfor (i = 0; i < outdatedModules.length; i++) {\n \t\t\tmoduleId = outdatedModules[i];\n \t\t\tif (\n \t\t\t\tinstalledModules[moduleId] &&\n \t\t\t\tinstalledModules[moduleId].hot._selfAccepted\n \t\t\t)\n \t\t\t\toutdatedSelfAcceptedModules.push({\n \t\t\t\t\tmodule: moduleId,\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\n \t\t\t\t});\n \t\t}\n\n \t\t// Now in \"dispose\" phase\n \t\thotSetStatus(\"dispose\");\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\n \t\t\tif (hotAvailableFilesMap[chunkId] === false) {\n \t\t\t\thotDisposeChunk(chunkId);\n \t\t\t}\n \t\t});\n\n \t\tvar idx;\n \t\tvar queue = outdatedModules.slice();\n \t\twhile (queue.length > 0) {\n \t\t\tmoduleId = queue.pop();\n \t\t\tmodule = installedModules[moduleId];\n \t\t\tif (!module) continue;\n\n \t\t\tvar data = {};\n\n \t\t\t// Call dispose handlers\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n \t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n \t\t\t\tcb = disposeHandlers[j];\n \t\t\t\tcb(data);\n \t\t\t}\n \t\t\thotCurrentModuleData[moduleId] = data;\n\n \t\t\t// disable module (this disables requires from this module)\n \t\t\tmodule.hot.active = false;\n\n \t\t\t// remove module from cache\n \t\t\tdelete installedModules[moduleId];\n\n \t\t\t// when disposing there is no need to call dispose handler\n \t\t\tdelete outdatedDependencies[moduleId];\n\n \t\t\t// remove \"parents\" references from all children\n \t\t\tfor (j = 0; j < module.children.length; j++) {\n \t\t\t\tvar child = installedModules[module.children[j]];\n \t\t\t\tif (!child) continue;\n \t\t\t\tidx = child.parents.indexOf(moduleId);\n \t\t\t\tif (idx >= 0) {\n \t\t\t\t\tchild.parents.splice(idx, 1);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// remove outdated dependency from module children\n \t\tvar dependency;\n \t\tvar moduleOutdatedDependencies;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\n \t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Not in \"apply\" phase\n \t\thotSetStatus(\"apply\");\n\n \t\thotCurrentHash = hotUpdateNewHash;\n\n \t\t// insert new code\n \t\tfor (moduleId in appliedUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\n \t\t\t}\n \t\t}\n\n \t\t// call accept handlers\n \t\tvar error = null;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tvar callbacks = [];\n \t\t\t\t\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[i];\n \t\t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\n \t\t\t\t\t\tif (cb) {\n \t\t\t\t\t\t\tif (callbacks.indexOf(cb) !== -1) continue;\n \t\t\t\t\t\t\tcallbacks.push(cb);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor (i = 0; i < callbacks.length; i++) {\n \t\t\t\t\t\tcb = callbacks[i];\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tcb(moduleOutdatedDependencies);\n \t\t\t\t\t\t} catch (err) {\n \t\t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n \t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\n \t\t\t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Load self accepted modules\n \t\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\n \t\t\tmoduleId = item.module;\n \t\t\thotCurrentParents = [moduleId];\n \t\t\ttry {\n \t\t\t\t__webpack_require__(moduleId);\n \t\t\t} catch (err) {\n \t\t\t\tif (typeof item.errorHandler === \"function\") {\n \t\t\t\t\ttry {\n \t\t\t\t\t\titem.errorHandler(err);\n \t\t\t\t\t} catch (err2) {\n \t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\terror: err2,\n \t\t\t\t\t\t\t\toriginalError: err\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\tif (!error) error = err2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// handle errors in accept handlers and self accepted module load\n \t\tif (error) {\n \t\t\thotSetStatus(\"fail\");\n \t\t\treturn Promise.reject(error);\n \t\t}\n\n \t\thotSetStatus(\"idle\");\n \t\treturn new Promise(function(resolve) {\n \t\t\tresolve(outdatedModules);\n \t\t});\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + chunkId + \".rapidoc-min.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// The chunk loading function for additional chunks\n \t// Since all referenced chunks are already included\n \t// in this file, this function is empty here.\n \t__webpack_require__.e = function requireEnsure() {\n \t\treturn Promise.resolve();\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(151)(__webpack_require__.s = 151);\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module shady-render\n */\nimport { isTemplatePartActive } from './template.js';\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let part = parts[partIndex];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we're removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            // go to the next active part.\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n            part = parts[partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there's no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            insertCount = countNodes(node);\n            refNode.parentNode.insertBefore(node, refNode);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we've inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { removeNodes } from './dom.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { marker, Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(`Incompatible ShadyCSS version detected.` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    const key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n    }\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.keyString.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn't support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll('style')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (renderedDOM, template, scopeName) => {\n    shadyRenderSet.add(scopeName);\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll('style');\n    // If there are no styles, skip unnecessary work\n    if (styles.length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);\n        return;\n    }\n    const condensedStyle = document.createElement('style');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < styles.length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the \"root\" template passed in as\n    // `template`.\n    insertNodeIntoTemplate(template, condensedStyle, template.element.content.firstChild);\n    // Note, it's important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);\n    if (window.ShadyCSS.nativeShadow) {\n        // When in native Shadow DOM, re-add styling to rendered content using\n        // the style ShadyCSS produced.\n        const style = template.element.content.querySelector('style');\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else {\n        // When not in native Shadow DOM, at this point ShadyCSS will have\n        // removed the style from the lit template and parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        template.element.content.insertBefore(condensedStyle, template.element.content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nexport const render = (result, container, options) => {\n    const scopeName = options.scopeName;\n    const hasRendered = parts.has(container);\n    const needsScoping = container instanceof ShadowRoot &&\n        compatibleShadyCSSVersion && result instanceof TemplateResult;\n    // Handle first render to a scope specially...\n    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n    // On first scope render, render into a fragment; this cannot be a single\n    // fragment that is reused since nested renders can occur synchronously.\n    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n    litRender(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When performing first scope render,\n    // (1) We've rendered into a fragment so that there's a chance to\n    // `prepareTemplateStyles` before sub-elements hit the DOM\n    // (which might cause them to render based on a common pattern of\n    // rendering in a custom element's `connectedCallback`);\n    // (2) Scope the template with ShadyCSS one time only for this scope.\n    // (3) Render the fragment into the container and make sure the\n    // container knows its `part` is the one we just rendered. This ensures\n    // DOM will be re-used on subsequent renders.\n    if (firstScopeRender) {\n        const part = parts.get(renderContainer);\n        parts.delete(renderContainer);\n        if (part.value instanceof TemplateInstance) {\n            prepareTemplateStyles(renderContainer, part.value.template, scopeName);\n        }\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        parts.set(container, part);\n    }\n    // After elements have hit the DOM, update styling if this is the\n    // initial render to this container.\n    // This is needed whenever dynamic changes are made so it would be\n    // safest to do every render; however, this would regress performance\n    // so we leave it up to the user to call `ShadyCSSS.styleElement`\n    // for dynamic changes.\n    if (!hasRendered && needsScoping) {\n        window.ShadyCSS.styleElement(container.host);\n    }\n};\n//# sourceMappingURL=shady-render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        }\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * @param tagName the name of the custom element to define\n *\n * In TypeScript, the `tagName` passed to `customElement` should be a key of the\n * `HTMLElementTagNameMap` interface. To add your element to the interface,\n * declare the interface in this module:\n *\n *     @customElement('my-element')\n *     export class MyElement extends LitElement {}\n *\n *     declare global {\n *       interface HTMLElementTagNameMap {\n *         'my-element': MyElement;\n *       }\n *     }\n *\n */\nexport const customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === 'function')\n    ? legacyCustomElement(tagName, classOrDescriptor)\n    : standardCustomElement(tagName, classOrDescriptor);\nconst standardProperty = (options, element) => {\n    // createProperty() takes care of defining the property, but we still must\n    // return some kind of descriptor, so return a descriptor for an unused\n    // prototype field. The finisher calls createProperty().\n    return {\n        kind: 'field',\n        key: Symbol(),\n        placement: 'own',\n        descriptor: {},\n        // When @babel/plugin-proposal-decorators implements initializers,\n        // do this instead of the initializer below. See:\n        // https://github.com/babel/babel/issues/9260 extras: [\n        //   {\n        //     kind: 'initializer',\n        //     placement: 'own',\n        //     initializer: descriptor.initializer,\n        //   }\n        // ],\n        initializer() {\n            if (typeof element.initializer === 'function') {\n                this[element.key] = element.initializer.call(this);\n            }\n        },\n        finisher(clazz) {\n            clazz.createProperty(element.key, options);\n        }\n    };\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A `PropertyDeclaration` may optionally be\n * supplied to configure property features.\n */\nexport const property = (options) => (protoOrDescriptor, name) => (name !== undefined)\n    ? legacyProperty(options, protoOrDescriptor, name)\n    : standardProperty(options, protoOrDescriptor);\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n */\nexport const query = _query((target, selector) => target.querySelector(selector));\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n */\nexport const queryAll = _query((target, selector) => target.querySelectorAll(selector));\nconst legacyQuery = (descriptor, proto, name) => { Object.defineProperty(proto, name, descriptor); };\nconst standardQuery = (descriptor, element) => ({\n    kind: 'method',\n    placement: 'prototype',\n    key: element.key,\n    descriptor,\n});\n/**\n * Base-implementation of `@query` and `@queryAll` decorators.\n *\n * @param queryFn exectute a `selector` (ie, querySelector or querySelectorAll)\n * against `target`.\n */\nfunction _query(queryFn) {\n    return (selector) => (protoOrDescriptor, name) => {\n        const descriptor = {\n            get() { return queryFn(this.renderRoot, selector); },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined)\n            ? legacyQuery(descriptor, protoOrDescriptor, name)\n            : standardQuery(descriptor, protoOrDescriptor);\n    };\n}\nconst standardEventOptions = (options, element) => {\n    return Object.assign({}, element, { finisher(clazz) {\n            Object.assign(clazz.prototype[element.key], options);\n        } });\n};\nconst legacyEventOptions = (options, proto, name) => { Object.assign(proto[name], options); };\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifis event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * @example\n *\n *     class MyElement {\n *\n *       clicked = false;\n *\n *       render() {\n *         return html`<div @click=${this._onClick}`><button></button></div>`;\n *       }\n *\n *       @eventOptions({capture: true})\n *       _onClick(e) {\n *         this.clicked = true;\n *       }\n *     }\n */\nexport const eventOptions = (options) => \n// Return value typed as any to prevent TypeScript from complaining that\n// standard decorator function signature does not match TypeScript decorator\n// signature\n// TODO(kschaaf): unclear why it was only failing on this decorator and not\n// the others\n((protoOrDescriptor, name) => (name !== undefined)\n    ? legacyEventOptions(options, protoOrDescriptor, name)\n    : standardEventOptions(options, protoOrDescriptor));\n//# sourceMappingURL=decorators.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { TemplateResult } from 'lit-html';\nimport { render } from 'lit-html/lib/shady-render';\nimport { UpdatingElement } from './lib/updating-element.js';\nexport * from './lib/updating-element.js';\nexport * from './lib/decorators.js';\nexport { html, svg, TemplateResult, SVGTemplateResult } from 'lit-html/lit-html';\nimport { supportsAdoptingStyleSheets } from './lib/css-tag.js';\nexport * from './lib/css-tag.js';\nexport class LitElement extends UpdatingElement {\n    /**\n     * Array of styles to apply to the element. The styles should be defined\n     * using the `css` tag function.\n     */\n    static get styles() { return []; }\n    static get _uniqueStyles() {\n        if (this._styles === undefined) {\n            const styles = this.styles;\n            // As a performance optimization to avoid duplicated styling that can\n            // occur especially when composing via subclassing, de-duplicate styles\n            // preserving the last item in the list. The last item is kept to\n            // try to preserve cascade order with the assumption that it's most\n            // important that last added styles override previous styles.\n            const styleSet = styles.reduceRight((set, s) => {\n                set.add(s);\n                // on IE set.add does not return the set.\n                return set;\n            }, new Set());\n            // Array.form does not work on Set in IE\n            this._styles = [];\n            styleSet.forEach((v) => this._styles.unshift(v));\n        }\n        return this._styles;\n    }\n    /**\n     * Performs element initialization. By default this calls `createRenderRoot`\n     * to create the element `renderRoot` node and captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        super.initialize();\n        this.renderRoot = this.createRenderRoot();\n        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n        // element's getRootNode(). While this could be done, we're choosing not to\n        // support this now since it would require different logic around de-duping.\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n            this.adoptStyles();\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\n     */\n    createRenderRoot() {\n        return this.attachShadow({ mode: 'open' });\n    }\n    /**\n     * Applies styling to the element shadowRoot using the `static get styles`\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\n     * end of the `shadowRoot` to [mimic spec\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n     */\n    adoptStyles() {\n        const styles = this.constructor._uniqueStyles;\n        if (styles.length === 0) {\n            return;\n        }\n        // There are three separate cases here based on Shadow DOM support.\n        // (1) shadowRoot polyfilled: use ShadyCSS\n        // (2) shadowRoot.adoptedStyleSheets available: use it.\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n        // rendering\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);\n        }\n        else if (supportsAdoptingStyleSheets) {\n            this.renderRoot.adoptedStyleSheets =\n                styles.map((s) => s.styleSheet);\n        }\n        else {\n            // This must be done after rendering so the actual style insertion is done\n            // in `update`.\n            this._needsShimAdoptedStyleSheets = true;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Note, first update/render handles styleElement so we only call this if\n        // connected after first update.\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\n            window.ShadyCSS.styleElement(this);\n        }\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    update(changedProperties) {\n        super.update(changedProperties);\n        const templateResult = this.render();\n        if (templateResult instanceof TemplateResult) {\n            this.constructor\n                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });\n        }\n        // When native Shadow DOM is used but adoptedStyles are not supported,\n        // insert styling after rendering to ensure adoptedStyles have highest\n        // priority.\n        if (this._needsShimAdoptedStyleSheets) {\n            this._needsShimAdoptedStyleSheets = false;\n            this.constructor._uniqueStyles.forEach((s) => {\n                const style = document.createElement('style');\n                style.textContent = s.cssText;\n                this.renderRoot.appendChild(style);\n            });\n        }\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method must return\n     * a lit-html TemplateResult. Setting properties inside this method will *not*\n     * trigger the element to update.\n     */\n    render() { }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n */\nLitElement.finalized = true;\n/**\n * Render method used to render the lit-html TemplateResult to the element's\n * DOM.\n * @param {TemplateResult} Template to render.\n * @param {Element|DocumentFragment} Node into which to render.\n * @param {String} Element name.\n * @nocollapse\n */\nLitElement.render = render;\n//# sourceMappingURL=lit-element.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        const _prepareTemplate = (template) => {\n            const content = template.content;\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n            // Keeps track of the last index associated with a part. We try to delete\n            // unnecessary nodes, but we never want to associate two different parts\n            // to the same index. They must have a constant node between.\n            let lastPartIndex = 0;\n            while (walker.nextNode()) {\n                index++;\n                const node = walker.currentNode;\n                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                    if (node.hasAttributes()) {\n                        const attributes = node.attributes;\n                        // Per\n                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                        // attributes are not guaranteed to be returned in document order.\n                        // In particular, Edge/IE can return them out of order, so we cannot\n                        // assume a correspondance between part index and attribute index.\n                        let count = 0;\n                        for (let i = 0; i < attributes.length; i++) {\n                            if (attributes[i].value.indexOf(marker) >= 0) {\n                                count++;\n                            }\n                        }\n                        while (count-- > 0) {\n                            // Get the template literal section leading up to the first\n                            // expression in this attribute\n                            const stringForPart = result.strings[partIndex];\n                            // Find the attribute name\n                            const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                            // Find the corresponding attribute\n                            // All bound attributes have had a suffix added in\n                            // TemplateResult#getHTML to opt out of special attribute\n                            // handling. To look up the attribute value we also need to add\n                            // the suffix.\n                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                            const attributeValue = node.getAttribute(attributeLookupName);\n                            const strings = attributeValue.split(markerRegex);\n                            this.parts.push({ type: 'attribute', index, name, strings });\n                            node.removeAttribute(attributeLookupName);\n                            partIndex += strings.length - 1;\n                        }\n                    }\n                    if (node.tagName === 'TEMPLATE') {\n                        _prepareTemplate(node);\n                    }\n                }\n                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                    const data = node.data;\n                    if (data.indexOf(marker) >= 0) {\n                        const parent = node.parentNode;\n                        const strings = data.split(markerRegex);\n                        const lastIndex = strings.length - 1;\n                        // Generate a new text node for each literal section\n                        // These nodes are also used as the markers for node parts\n                        for (let i = 0; i < lastIndex; i++) {\n                            parent.insertBefore((strings[i] === '') ? createMarker() :\n                                document.createTextNode(strings[i]), node);\n                            this.parts.push({ type: 'node', index: ++index });\n                        }\n                        // If there's no text, we must insert a comment to mark our place.\n                        // Else, we can trust it will stick around after cloning.\n                        if (strings[lastIndex] === '') {\n                            parent.insertBefore(createMarker(), node);\n                            nodesToRemove.push(node);\n                        }\n                        else {\n                            node.data = strings[lastIndex];\n                        }\n                        // We have a part for each match found\n                        partIndex += lastIndex;\n                    }\n                }\n                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                    if (node.data === marker) {\n                        const parent = node.parentNode;\n                        // Add a new marker node to be the startNode of the Part if any of\n                        // the following are true:\n                        //  * We don't have a previousSibling\n                        //  * The previousSibling is already the start of a previous part\n                        if (node.previousSibling === null || index === lastPartIndex) {\n                            index++;\n                            parent.insertBefore(createMarker(), node);\n                        }\n                        lastPartIndex = index;\n                        this.parts.push({ type: 'node', index });\n                        // If we don't have a nextSibling, keep this node so we have an end.\n                        // Else, we can remove it to save future costs.\n                        if (node.nextSibling === null) {\n                            node.data = '';\n                        }\n                        else {\n                            nodesToRemove.push(node);\n                            index--;\n                        }\n                        partIndex++;\n                    }\n                    else {\n                        let i = -1;\n                        while ((i = node.data.indexOf(marker, i + 1)) !==\n                            -1) {\n                            // Comment node has a binding marker inside, make an inactive part\n                            // The binding won't work, but subsequent bindings will\n                            // TODO (justinfagnani): consider whether it's even worth it to\n                            // make bindings in comments work\n                            this.parts.push({ type: 'node', index: -1 });\n                        }\n                    }\n                }\n            }\n        };\n        _prepareTemplate(element);\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = (value) => (value === null ||\n    !(typeof value === 'object' || typeof value === 'function'));\n/**\n * Sets attribute values for AttributeParts, so that the value is only set once\n * even if there are multiple parts for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (v != null &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n                else {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\nexport class AttributePart {\n    constructor(comitter) {\n        this.value = undefined;\n        this.committer = comitter;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\nexport class NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Inserts this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and\n     * its next sibling must be static, unchanging nodes such as those that appear\n     * in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part._insert(this.startNode = createMarker());\n        part._insert(this.endNode = createMarker());\n    }\n    /**\n     * Appends this part after `ref`\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref._insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        const value = this._pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this._commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this._commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this._commitNode(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this.value = value;\n    }\n    _commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = value;\n        }\n        else {\n            this._commitNode(document.createTextNode(typeof value === 'string' ? value : String(value)));\n        }\n        this.value = value;\n    }\n    _commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value && this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this._commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        const value = !!this._pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        this.value = value;\n        this._pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\ntry {\n    const options = {\n        get capture() {\n            eventOptionsSupported = true;\n            return false;\n        }\n    };\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n}\ncatch (_e) {\n}\nexport class EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this._boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        const newListener = this._pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this._boundHandleEvent, this._options);\n        }\n        if (shouldAddListener) {\n            this._options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this._boundHandleEvent, this._options);\n        }\n        this.value = newListener;\n        this._pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nexport const nothing = {};\n//# sourceMappingURL=part.js.map","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter } from './parts.js';\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const comitter = new PropertyCommitter(element, name.slice(1), strings);\n            return comitter.parts;\n        }\n        if (prefix === '@') {\n            return [new EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const comitter = new AttributeCommitter(element, name, strings);\n        return comitter.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new NodePart(options);\n    }\n}\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor.js';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { DefaultTemplateProcessor, defaultTemplateProcessor } from './lib/default-template-processor.js';\nexport { directive, isDirective } from './lib/directive.js';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport { removeNodes, reparentNodes } from './lib/dom.js';\nexport { noChange, nothing } from './lib/part.js';\nexport { AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isPrimitive, NodePart, PropertyCommitter, PropertyPart } from './lib/parts.js';\nexport { parts, render } from './lib/render.js';\nexport { templateCaches, templateFactory } from './lib/template-factory.js';\nexport { TemplateInstance } from './lib/template-instance.js';\nexport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { createMarker, isTemplatePartActive, Template } from './lib/template.js';\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    window.customElements.polyfillWrapFlushCallback !== undefined;\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=dom.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { reparentNodes } from './dom.js';\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template.js';\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const endIndex = this.strings.length - 1;\n        let html = '';\n        for (let i = 0; i < endIndex; i++) {\n            const s = this.strings[i];\n            // This exec() call does two things:\n            // 1) Appends a suffix to the bound attribute name to opt out of special\n            // attribute value parsing that IE11 and Edge do, like for style and\n            // many SVG attributes. The Template class also appends the same suffix\n            // when looking up attributes to create Parts.\n            // 2) Adds an unquoted-attribute-safe marker for the first expression in\n            // an attribute. Subsequent attribute expressions will use node markers,\n            // and this is safe since attributes with multiple expressions are\n            // guaranteed to be quoted.\n            const match = lastAttributeNameRegex.exec(s);\n            if (match) {\n                // We're starting a new bound attribute.\n                // Add the safe attribute suffix, and use unquoted-attribute-safe\n                // marker.\n                html += s.substr(0, match.index) + match[1] + match[2] +\n                    boundAttributeSuffix + match[3] + marker;\n            }\n            else {\n                // We're either in a bound node, or trailing bound attribute.\n                // Either way, nodeMarker is safe to use.\n                html += s + nodeMarker;\n            }\n        }\n        return html + this.strings[endIndex];\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { marker, Template } from './template.js';\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nexport const templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive so that lit-html will call the function\n * during template rendering, rather than passing as a value.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object\n *\n * @example\n *\n * ```\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n * ```\n */\nexport const directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nexport const isDirective = (o) => typeof o === 'function' && directives.has(o);\n//# sourceMappingURL=directive.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { removeNodes } from './dom.js';\nimport { NodePart } from './parts.js';\nimport { templateFactory } from './template-factory.js';\nexport const parts = new WeakMap();\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render = (result, container, options) => {\n    let part = parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, processor, options) {\n        this._parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // When using the Custom Elements polyfill, clone the node, rather than\n        // importing it, to keep the fragment in the template's document. This\n        // leaves the fragment inert so custom elements won't upgrade and\n        // potentially modify their contents by creating a polyfilled ShadowRoot\n        // while we traverse the tree.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const parts = this.template.parts;\n        let partIndex = 0;\n        let nodeIndex = 0;\n        const _prepareInstance = (fragment) => {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n            let node = walker.nextNode();\n            // Loop through all the nodes and parts of a template\n            while (partIndex < parts.length && node !== null) {\n                const part = parts[partIndex];\n                // Consecutive Parts may have the same node index, in the case of\n                // multiple bound attributes on an element. So each iteration we either\n                // increment the nodeIndex, if we aren't on a node with a part, or the\n                // partIndex if we are. By not incrementing the nodeIndex when we find a\n                // part, we allow for the next part to be associated with the current\n                // node if neccessasry.\n                if (!isTemplatePartActive(part)) {\n                    this._parts.push(undefined);\n                    partIndex++;\n                }\n                else if (nodeIndex === part.index) {\n                    if (part.type === 'node') {\n                        const part = this.processor.handleTextExpression(this.options);\n                        part.insertAfterNode(node.previousSibling);\n                        this._parts.push(part);\n                    }\n                    else {\n                        this._parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n                    }\n                    partIndex++;\n                }\n                else {\n                    nodeIndex++;\n                    if (node.nodeName === 'TEMPLATE') {\n                        _prepareInstance(node.content);\n                    }\n                    node = walker.nextNode();\n                }\n            }\n        };\n        _prepareInstance(fragment);\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isPrimitive } from '../lib/parts.js';\nimport { directive, NodePart } from '../lit-html.js';\n// For each part, remember the value that was last rendered to the part by the\n// unsafeHTML directive, and the DocumentFragment that was last set as a value.\n// The DocumentFragment is used as a unique key to check if the last value\n// rendered to the part was with unsafeHTML. If not, we'll always re-render the\n// value passed to unsafeHTML.\nconst previousValues = new WeakMap();\n/**\n * Renders the result as HTML, rather than text.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive((value) => (part) => {\n    if (!(part instanceof NodePart)) {\n        throw new Error('unsafeHTML can only be used in text bindings');\n    }\n    const previousValue = previousValues.get(part);\n    if (previousValue !== undefined && isPrimitive(value) &&\n        value === previousValue.value && part.value === previousValue.fragment) {\n        return;\n    }\n    const template = document.createElement('template');\n    template.innerHTML = value;\n    const fragment = document.importNode(template.content, true);\n    part.setValue(fragment);\n    previousValues.set(part, { value, fragment });\n});\n//# sourceMappingURL=unsafe-html.js.map","let color={\n    bg:\"#fff\", \n    fg:\"#333\",\n    lightFg:\"#999\",\n    veryLightFg:\"#bbb\",\n    codeFg:\"#ccc\",\n    codeBg:\"#263238\",\n    reverseBg:\"#333\", \n    reverseFg:\"#ccc\",\n    primaryBg:\"#FF791A\",\n    primaryFg:\"#fff\",\n    plainBg:\"#fff\",\n    plainFg:\"#333\",\n    plainBtnBorder:\"#333\",\n    inputFg:\"#333\",\n    inputBg:\"#fff\",\n    tableFg:\"#565656\",\n    tableHeaderBg:\"#fafafa\",\n    tableTitleFg:\"#999\",\n    inputBorder:\"#C5D9E8\",\n    inputReverseFg:\"#fff\",\n    inputReverseBg:\"#333\",\n    inputReverseBorder:\"#cd5500\",\n    inputReverseBorderFocus:\"#FF791A\",\n    link:'#47AFE8',\n    border:\"#ccc\",\n    lightBorder:\"#eee\",\n    red:\"#CC0000\",\n    softRed:\"#ED4337\",\n    green:\"#99CC00\",\n    blue:\"#47AFE8\",\n    orange:\"#FF9900\",\n    get:\"#47AFE8\",\n    put:\"#FF9900\",\n    post:\"#99CC00\",\n    delete:\"#CC0000\",\n    patch:\"#fc0\",\n    head:\"\",\n    lightGet:\"#eff8fd\",\n    lightPut:\"#fff5e6\",\n    lightPost:\"#fbfff0\",\n    lightDelete:\"#fff0f0\",\n    lightPatch:\"#fff5cc\",\n    lightHead:\"\",\n    headerBg:\"#444\",\n    hoverBg:\"#f7f7f7\",\n    placeHolder:\"#ccc\",\n    getRgb:function(hex){\n        if (hex.indexOf('#') === 0) {\n            hex = hex.slice(1);\n        }\n        // convert 3-digit hex to 6-digits.\n        if (hex.length === 3) {\n            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n        }\n        if (hex.length !== 6) {\n            throw new Error('Invalid HEX color.');\n        }\n        return{\n           'r' :parseInt(hex.slice(0, 2), 16),\n           'g' :parseInt(hex.slice(2, 4), 16),\n           'b' :parseInt(hex.slice(4, 6), 16),\n        }\n\n    },\n    invert:function(hex){\n        let rgb = this.getRgb(hex);\n        return (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) > 186 ? '#333': '#fff';\n    },\n    opacity:function(hex, opacity){\n        let rgb = this.getRgb(hex);\n        return `rgba(${rgb.r}, ${rgb.r}, ${rgb.r}, ${opacity})`;\n    },\n    brightness(hex, amt){\n        let rgb = this.getRgb(hex);\n        rgb.r = rgb.r + amt;\n        rgb.g = rgb.g + amt;\n        rgb.b = rgb.b + amt;\n        if (rgb.r > 255) rgb.r = 255;\n        else if (rgb.r < 0) rgb.r = 0;\n\n        if (rgb.g > 255) rgb.g = 255;\n        else if (rgb.g < 0) rgb.g = 0;\n\n        if (rgb.b > 255) rgb.b = 255;\n        else if (rgb.b < 0) rgb.b = 0;\n        return `#${rgb.r.toString(16).padStart(2, '0')}${rgb.g.toString(16).padStart(2, '0')}${rgb.b.toString(16).padStart(2, '0')}`\n    }\n};\n\nlet border={\n    \"radius\":\"2px\",\n    \"style\":\"1px solid gray\",\n};\n\nlet font={\n    path:\"/public\",\n    regular:'rapidoc, Helvetica, Arial',\n    mono:\"Monaco, 'Andale Mono', 'Roboto Mono', Consolas\",\n    size:'14px',\n    small:'12px',\n    titleSize:'16px',\n    tableTitleSize:\"12px\"\n}\n\nexport default {\n    color,\n    font,\n    border\n}","import { LitElement, html } from 'lit-element'; \nimport vars from '@/styles/vars';\n// Create your custom component\nexport default class JsonTree extends LitElement {\n  render() {\n    return html`\n      <style>\n        .tree{\n          font-family: ${vars.font.mono};\n          font-size:12px;\n          display:inline-block;\n          overflow:hidden;\n          width:100%;\n        }\n        .item{\n          white-space: nowrap;\n        }\n        .left-bracket{\n          display:inline-block;\n          padding: 0 20px 0 0;\n          cursor:pointer;\n          border: 1px solid transparent;\n          border-radius:3px;\n        }\n        .left-bracket:hover{\n          color:var(--primary-color);\n          background-color:var(--hover-color);\n          border: 1px solid var(--border-color);\n        }\n        .inside-bracket{\n          padding-left:12px;\n          border-left:1px dotted var(--border-color);\n        }\n        .string{color:#86b300;}\n        .number{color:#47afe8;}\n        .null{color:orangered;}\n        .boolean{color:#b96ff1}\n        .object{color:var(--fg)}\n      </style>\n      <div class=\"tree\">\n        ${this.generateTree(this.data)}\n      </div>  \n    `\n  }\n\n  static get properties() {\n    return {\n      data:{type: Object}\n    };\n  }\n\n  generateTree(data){\n    if (data===null){\n      return html`<div class=\"null\" style=\"display:inline;\">null</div>`\n    }\n    if (typeof data === 'object'){\n      let detailType = Array.isArray(data)?\"array\":\"pure_object\";\n      if (Object.keys(data).length===0){\n        return html`${ (Array.isArray(data)?'[ ]':'{ }') }`\n      }\n      return html`\n      <div class=\"left-bracket expanded ${detailType==='array'?'array':'object'} \" @click=\"${this.toggleExpand}\" > ${detailType==='array'?'[':'{'}</div>\n        <div class=\"inside-bracket\">\n        ${Object.keys(data).map(key => \n          html`<div class=\"item\"> ${detailType==='pure_object'?html`${key}:`:``}${this.generateTree(data[key])}</div>`\n        )}\n        </div>\n      <div class=\"right-bracket\">${detailType==='array'?']':'}'}</div>\n      `\n    }\n    else{\n      return typeof data==='string'?html`<span class=\"${typeof data}\">\"${data}\"</span>`: html`<span class=\"${typeof data}\">${data}</span>`;\n    }\n\n  }\n\n  toggleExpand(e){\n    console.log(e.target.nextElementSibling);\n    if (e.target.classList.contains(\"expanded\")){\n      e.target.classList.add(\"collapsed\");\n      e.target.classList.remove(\"expanded\");\n      e.target.innerHTML = e.target.classList.contains(\"array\")? \"[...]\":\"{...}\";\n      e.target.nextElementSibling.style.display = \"none\";\n      e.target.nextElementSibling.nextElementSibling.style.display= \"none\";\n    }\n    else{\n      e.target.classList.remove(\"collapsed\");\n      e.target.classList.add(\"expanded\");\n      e.target.innerHTML = e.target.classList.contains(\"array\")? \"[\":\"{\";\n      e.target.nextElementSibling.style.display = \"block\";\n      e.target.nextElementSibling.nextElementSibling.style.display= \"block\";\n    }\n\n    //console.log(e.target.parentElement.querySelectorAll(\":scope > .inside-bracket\"));\n  }\n}\n// Register the element with the browser\ncustomElements.define('json-tree', JsonTree);\n","import { LitElement, html } from 'lit-element'; \nimport vars from '@/styles/vars';\nimport marked from 'marked';\nimport {unsafeHTML} from 'lit-html/directives/unsafe-html.js';\n// Create your custom component\nexport default class SchemaTree extends LitElement {\n  render() {\n    return html`\n      <style>\n        .tree{\n          font-family: ${vars.font.mono};\n          font-size:12px;\n          display:inline-block;\n          overflow:hidden;\n          width:100%;\n        }\n        .item{\n          white-space: nowrap;\n          display: table;\n        }\n        .item-key{\n          display:inline;\n        }\n        .item-value{\n          display: table-cell;\n          white-space: normal;\n        }\n        .item-type{\n          display: table-cell;\n          min-width:100px;\n        }\n        .obj-descr{\n          color:var(--very-light-fg);\n          font-family:${vars.font.regular};\n          display:inline;\n        }\n        .item-descr{\n          color:var(--light-fg);\n          display: table-cell;\n          padding-left:24px;\n          min-width: 200px;\n          font-family:${vars.font.regular};\n        }\n        .descr-expander{\n          display: table-cell;\n          cursor:pointer;\n          color:orange;\n        }\n        .left-bracket{\n          display:inline-block;\n          padding: 0 20px 0 0;\n          cursor:pointer;\n          border: 1px solid transparent;\n          border-radius:3px;\n        }\n        .left-bracket:hover{\n          color:var(--primary-color);\n          background-color:var(--hover-color);\n          border: 1px solid var(--border-color);\n        }\n        .inside-bracket{\n          padding-left:12px;\n          border-left:1px dotted var(--border-color);\n        }\n        .m-markdown > p{\n          margin-block-start:0;\n          margin-block-end:5px;\n        }\n        .stri, .string{color:#86b300;}\n        .inte, .number{color:#47afe8;}\n        .null {color:orangered;}\n        .bool, .boolean{color:#b96ff1}\n        .enum {color:orange}\n      </style>\n      <div class=\"tree\">\n        ${this.generateTree(this.data)}\n      </div>  \n    `\n  }\n\n  static get properties() {\n    return {\n      data:{type: Object}\n    };\n  }\n\n  generateTree(data){\n    if (data===null){\n      return html`<div class=\"null\" style=\"display:inline;\">null</div>`\n    }\n    if (typeof data === 'object'){\n      let detailType = Array.isArray(data)?\"array\":\"pure_object\";\n      if (Object.keys(data).length===0){\n        return html`${ (Array.isArray(data)?'[ ]':'{ }') }`\n      }\n      if (Object.keys(data).length===1 && Object.keys(data)[0]===':description'){\n        return html`${ (Array.isArray(data)?'[ ]':'{ }') } <span class='obj-descr'> ${data[':description']} </span>`\n      }\n      return html`\n      <div class=\"left-bracket expanded ${detailType==='array'?'array':'object'} \" @click=\"${this.toggleExpand}\" > ${detailType==='array'?'[':'{'}</div>\n        ${data[':description']?html`<span class='obj-descr obj-content-part'> ${data[':description']} </span>`:''}\n        <div class=\"inside-bracket obj-content-part\" >\n        ${Object.keys(data).map(\n          key => html`\n            ${key!==':description'? html`<div class=\"item\"> <span class=\"item-key\"> \n              ${detailType==='pure_object'?html`${key}:`\n              :``} \n            </span>${this.generateTree(data[key])}</div>`\n            :''}`\n        )}\n        </div>\n      <div class=\"right-bracket obj-content-part\">${detailType==='array'?']':'}'}</div>\n      `\n    }\n    else{\n      return html`<span class=\"item-value\">\n        ${data.split(\"~|~\").map(\n          (item,idx) => html`\n            ${item? html`<div class='${idx==0?'item-type ' + item.substring(0,4):'m-markdown item-descr'}'>\n              ${idx==0?html`${item}`:html`${unsafeHTML(marked(item))}`\n              }</div>`\n            :``}`\n        )}</span>`\n    }\n\n  }\n\n  toggleExpand(e){\n    if (e.target.classList.contains(\"expanded\")){\n      e.target.classList.add(\"collapsed\");\n      e.target.classList.remove(\"expanded\");\n      e.target.innerHTML = e.target.classList.contains(\"array\")? \"[...]\":\"{...}\";\n      let els = e.target.parentNode.querySelectorAll(\":scope > .obj-content-part\")\n      els.forEach( el => el.style.display='none');\n    }\n    else{\n      e.target.classList.remove(\"collapsed\");\n      e.target.classList.add(\"expanded\");\n      e.target.innerHTML = e.target.classList.contains(\"array\")? \"[\":\"{\";\n      let els = e.target.parentNode.querySelectorAll(\":scope > .obj-content-part\");\n      els.forEach( el =>  el.style.display=  el.classList.contains(\"obj-descr\")?'inline':'block');\n    }\n\n    //console.log(e.target.parentElement.querySelectorAll(\":scope > .inside-bracket\"));\n  }\n  toggleDescr(){\n    console.log(\"descr\")\n  }\n}\n// Register the element with the browser\ncustomElements.define('schema-tree', SchemaTree);\n","import vars from './vars';\nimport {html} from 'lit-element'; \n\nexport default html`\n<style>\ntable {\n  border-spacing: 0;\n}\ntd, th {\n  display: table-cell;\n  vertical-align: inherit;\n}\n\n.m-table {\n  border-collapse: separate;\n  border: 1px solid var(--border-color);\n  border-radius: ${vars.border.radius};\n  color: ${vars.color.tableFg};\n  margin: 0;\n  max-width: 100%;\n}\n\n.m-table tr:first-child td,\n.m-table tr:first-child th {\n    border-top: 0 none;\n}\n.m-table td, \n.m-table th{\n    font-size: 12px;\n    line-height: 16px;\n    padding: 4px 5px 4px;\n    text-align: left;\n    vertical-align: top;\n}\n\n.m-table th {\n    color: ${vars.color.tableFg};\n    font-size: 12px;\n    line-height:30px;\n    font-weight: 600;\n    letter-spacing: normal;\n    background-color: ${vars.color.tableHeaderBg};\n    vertical-align: bottom;\n    border-bottom: 1px solid var(--border-color);\n}\n\n.m-table > tbody >tr > td,\n.m-table > tr > td{\n    border-top: 1px solid var(--light-border-color);\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.m-table tr:hover{\n    background-color: var(--hover-color);\n}\n.table-title{\n    font-size:${vars.font.tableTitleSize};\n    color:${vars.color.tableTitleFg};\n    font-weight:bold;\n    vertical-align: middle;\n    margin: 12px 0 4px 0;\n}\n\n</style>`\n","import vars from './vars';\nimport {html} from 'lit-element'; \n\nexport default html`\n<style>\n  .row, .col{\n    display:flex;\n  } \n  .row{\n    align-items:center;\n    flex-direction: row;\n  }\n  .col{\n    align-items:stretch;\n    flex-direction: column;\n  }\n</style>`\n","import vars from './vars';\nimport {html} from 'lit-element'; \n\nexport default html`\n<style>\ninput, select, button {\n  font-family: ${vars.font.regular};\n  font-weight:400;\n  color:var(--fg);\n}\n\n/* Button */\n.m-btn{\n  border-radius: ${vars.border.radius};\n  font-weight: 600;\n  display: inline-block;\n  padding: 6px 16px;\n  font-size: 12px;\n  outline: 0;\n  line-height: 1;\n  text-align: center;\n  white-space: nowrap;\n  background-color:var(--primary-color);\n  color:var(--primary-text);\n  border: 1px solid var(--primary-color);\n  transition: background-color 0.2s;\n  user-select: none;\n  cursor: pointer;\n}\n\n.m-btn.large{padding:8px 14px;}\n.m-btn.small{padding:5px 12px;}\n.m-btn.circle{border-radius:50%;}\n.m-btn:hover{ background-color: var(--primary-color)}\n\n/* Form Inputs */\ntextarea,\ninput[type=\"text\"],\ninput[type=\"password\"]{\n  border-radius:${vars.border.radius};\n  border:1px solid var(--input-border-color);\n  background:var(--input-bg);\n  color:var(--fg);\n  transition: border .2s;\n  outline: none;\n  font-size:14px;\n  height:26px;\n  padding: 0 5px;\n  box-sizing: border-box;\n}\n\ntextarea.mono,\ninput[type=\"text\"].mono,\ninput[type=\"password\"].mono{\n  font-family: ${vars.font.mono}; \n  font-size:12px;\n}\n\ninput[type=\"text\"].small,\ninput[type=\"password\"].small {\n    height:26px;\n    font-size:12px;\n}\n\ntextarea::placeholder,\ninput[type=\"text\"]::placeholder,\ninput[type=\"password\"]::placeholder {\n    color: var(--placeholder-color);\n}\n\ntextarea:focus,\ninput[type=\"text\"]:focus,\ninput[type=\"password\"]:focus,\ntextarea:active,\ninput[type=\"text\"]:active,\ninput[type=\"password\"]:active {\n    border:1px solid var(--primary-color);\n}\n\ntextarea.reverse,\ninput.reverse[type=\"text\"],\ninput.reverse[type=\"password\"]{\n  background:${vars.color.inputReverseBg};\n  color:${vars.color.inputReverseFg};\n  border:1px solid var(--primary-color); \n}\n\ntextarea.reverse:focus,\ninput.reverse[type=\"text\"]:focus,\ninput.reverse[type=\"password\"]:focus,\ntextarea.reverse:active,\ninput.reverse[type=\"text\"]:active,\ninput.reverse[type=\"password\"]:active{\n    border:1px solid var(--primary-color);\n}\n\ntextarea.reverse::placeholder,\ninput.reverse::placeholder{\n    color: #666;\n}\n\ntextarea::-webkit-scrollbar-track{\n    background-color: transparent;\n}\n  \ntextarea::-webkit-scrollbar{\n    width: 8px;\n    height: 8px;\n    background-color: transparent;\n}\n \ntextarea::-webkit-scrollbar-thumb {\n    background-color: rgba(50,50,50, .5);\n}\n</style>`\n","import vars from './vars';\nimport {html} from 'lit-element'; \n\nexport default html`\n<style>\n    .regular-font{font-family:${vars.font.regular};}\n    .mono-font{font-family:${vars.font.mono};}\n\n    h1{ font-family:${vars.font.regular}; font-size:26px; font-weight:200; letter-spacing:normal; }\n    h2{ font-family:${vars.font.regular}; font-size:24px; font-weight:200; letter-spacing:normal; }\n    h3{ font-family:${vars.font.regular}; font-size:22px; font-weight:200; letter-spacing:normal; }\n    h4{ font-family:${vars.font.regular}; font-size:18px; font-weight:200; letter-spacing:normal; }\n    h5{ font-family:${vars.font.regular}; font-size:16px; font-weight:200; letter-spacing:normal; }\n    h6{ font-family:${vars.font.regular}; font-size:14px; font-weight:200; letter-spacing:normal; }\n\n    h1,h2,h3,h4,h5,h5{\n      margin-block-end: 0.2em;\n    }\n    p{margin-block-start: 0.5em;}\n    code,\n    pre{\n      font-family: ${vars.font.mono};\n    }\n\n    /* Text */\n    .m-text{vertical-align: middle;}\n    .m-text.small{font-size: 12px;line-height: 12px;}\n    .m-text.gray{color: var(--light-fg)}\n    .m-text.primary{color: var(--primary-color); }\n    .m-text.bold{font-weight:bold;}\n    .m-text.bottom-margin{ margin-bottom:4px}\n    \n    /* Sub Title */\n    .m-sub-title {\n      font-size:20px;\n      white-space:nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n\n    .m-sub-title.m-1{\n      font-size: 16px;\n      font-weight:bold;\n      margin: 20px 0 4px 0;\n    }\n\n    .m-sub-title.m-2{\n      font-size: 14px;\n      font-weight:bold;\n      margin: 16px 0 4px 0;\n    }\n\n    .m-sub-title.m-3 {\n        font-size: 12px;\n        font-weight:bold;\n        margin: 12px 0 4px 0;\n    }\n\n    /* Markdown */\n    .m-markdown p:only-child{\n        color:var(--light-fg);\n        font-size:12px;\n        line-height:normal;\n        margin-top:0;\n    }\n    .m-markdown p{\n        line-height: 16px;\n    }\n    .m-markdown code{\n        background-color: rgba(0, 0, 0, 0.02);\n        padding: 0px 6px;\n        border: 1px solid var(--light-border-color);\n        border-radius: 3px;\n        color: var(--fg);\n        font-size: 12px;\n    }\n\n    .m-markdown pre{\n        white-space: pre-wrap;\n        background-color: var(--pre-bg);\n        color:var(--pre-fg);\n        padding: 12px 14px 15px 14px;\n        overflow-x: auto;\n        line-height: normal;\n        border-radius: 4px;\n        border: 1px solid var(--pre-border-color);\n    }\n    .m-markdown pre code {\n        border:none;\n        background-color:transparent;\n        color: var(--code-fg);\n    }\n    .m-markdown ul,\n    .m-markdown ol{\n        padding-inline-start:30px\n    }\n    .m-markdown li{\n        line-height: 1.2em;\n    }\n    .m-markdown a{color:var(--link-color)}\n</style>`\n","import {html} from 'lit-element'; \nimport vars from './vars';\nexport default html`\n<style>\na{ color: ${vars.color.link}; }\n.border{\n  border:1px solid ${vars.color.border};\n  border-radius: ${vars.border.radius};\n}\n.light-border{\n  border:1px solid ${vars.color.lightBorder};\n  border-radius: ${vars.border.radius};\n}\n</style>`\n","/* For Delayed Event Handler Execution */\nfunction debounce (fn, delay) {\n    var timeoutID = null;\n    return function () {\n      clearTimeout(timeoutID)\n      var args = arguments\n      var that = this\n      timeoutID = setTimeout(function () {\n        fn.apply(that, args)\n      }, delay)\n    }\n}\n\nfunction copyToClipboard(elId) {\n    /* Get the text field */\n    var copyText = document.getElementById(elId);\n  \n    /* Select the text field */\n    copyText.select();\n  \n    /* Copy the text inside the text field */\n    document.execCommand(\"copy\");\n    return copyText.value;\n}\n\n/* Generates an HTML string containing type and constraint info */\nfunction getTypeInfo(schema, overrideAttributes=null, inSingleLine=true){\n    let html =\"\";\n    if (schema.type===\"circular\"){\n        return \"circular-ref\";\n    }\n    if (schema.enum){\n        let opt=\"\"\n        schema.enum.map(function(v){\n            opt = opt + v + \", \"\n        });\n        html = `enum:\\u3014 ${opt.slice(0,-2)} \\u3015`\n    }\n    else if (schema.type){\n        html = html + schema.type ;\n    }\n    \n    if (schema.type===\"integer\" || schema.type===\"number\"){\n        if (schema.minimum !== undefined && schema.maximum!==undefined){\n            html = `${html} (${schema.exclusiveMinimum?\">\":\"\"}${schema.minimum} \\u22ef ${schema.exclusiveMaximum?\"<\":\"\"} ${schema.maximum})`\n            //html = html+\" ( \" + (schema.exclusiveMinimum?\"> \":\"\") + schema.minimum + \" to \" +  (schema.exclusiveMaximum?\"< \":\"\") + schema.maximum + \" )\";\n        }\n        else if (schema.minimum!==undefined && schema.maximum===undefined){\n            html = `${html} (${schema.exclusiveMinimum?\">\":\"\\u2265\"}${schema.minimum})`\n            //html = html+\" ( \" + (schema.exclusiveMinimum?\"> \":\">=\") + schema.minimum + \" )\";\n        }\n        else if (schema.minimum===undefined && schema.maximum!==undefined){\n            html = `(${schema.exclusiveMaximum?\"<\":\"\\u2264\"}${schema.maximum})`\n            //html = html+\" ( \" + (schema.exclusiveMaximum?\"< \":\"<=\") + schema.maximum + \" )\";\n        }\n        if (schema.multipleOf!==undefined){\n            html = `(multiple of ${schema.multipleOf})`\n            //html = html+\" ( multiple of:\" + schema.multipleOf+ \" )\";\n        }\n    }\n\n    if (schema.type===\"string\"){\n        if (schema.minLength !==undefined  && schema.maxLength !==undefined ){\n            html = `${html} (${schema.minLength} to ${schema.maxLength} chars)`;\n            //html = html+\" ( length: \" + schema.minLength + \" to \" + schema.maxLength +\" )\";\n        }\n        else if (schema.minLength!==undefined  && chema.maxLength===undefined ){\n            html = `${html} (min:${schema.minLength})`;\n            //html = html+\" ( min-length: \" + schema.minLength + \" )\";\n        }\n        else if (schema.minLength===undefined  && schema.maxLength!==undefined ){\n            html = `${html} (max:${schema.maxLength})`;\n            //html = html+\" ( max-length: \" + schema.maxLength +\" )\";\n        }\n    }\n\n    if (overrideAttributes){\n        if (overrideAttributes.readOnly){\n            html = `${html} \\u24C7`;\n        }\n        if (overrideAttributes.writeOnly){\n            html = `${html} \\u24CC`;\n        }\n        if (overrideAttributes.deprecated){\n            html = `${html} \\u274c`;\n        }\n    }\n    else{\n        if (schema.readOnly){\n            html = `${html} \\u24C7`;\n        }\n        if (schema.writeOnly){\n            html = `${html} \\u24CC`;\n        }\n        if (schema.deprecated){\n            html = `${html} \\u274c`;\n        }\n    }\n\n\n    let lineBreak = inSingleLine?\"\":\"<br/>\";\n    if (schema.format){\n        html = html + ` ${lineBreak} (${schema.format})`;    \n    }\n    if (schema.pattern){\n        html = html + ` ${lineBreak}(${schema.pattern})`;    \n    }\n    return html;\n}\n\n\n/* For changing JSON-Schema to a Object Model that can be represnted in a tree-view */ \nfunction schemaToModel (schema, obj) {\n    if (schema==null){\n        return;\n    }\n    if (schema.type===\"object\" || schema.properties){\n        if (schema.description){\n            obj[\":description\"] = schema.description;\n        }\n        for( let key in schema.properties ){\n            obj[key] = schemaToModel(schema.properties[key],{});\n        }\n    }\n    else if (schema.type===\"array\" || schema.items ){\n        //let temp = Object.assign({}, schema.items );\n        obj = [schemaToModel(schema.items,{})  ]\n    }\n    else if (schema.allOf ){\n        if (schema.allOf.length===1){\n            if (!schema.allOf[0]){\n                return `string~|~${schema.description?schema.description:''}`;\n            }\n            else{\n                let overrideAttrib = { \n                    \"readOnly\":schema.readOnly, \n                    \"writeOnly\":schema.writeOnly, \n                    \"depricated\":schema.deprecated\n                };\n                return `${ getTypeInfo(schema.allOf[0],overrideAttrib) }~|~${schema.description?schema.description:''}`\n            }\n        }\n\n        // If allOf is an array of multiple elements, then they are the keys of an object\n        let objWithAllProps = {};\n        schema.allOf.map(function(v){\n            if (v && v.properties){\n                let partialObj = schemaToModel(v,{});\n                Object.assign(objWithAllProps, partialObj);\n            }\n        });\n        obj = objWithAllProps;\n    }\n    else{\n        return `${getTypeInfo(schema)}~|~${schema.description?schema.description:''}`;\n    }\n    return obj;\n}\n\n\n\n\n/* Create Example object */\nfunction generateExample(examples, example, schema, mimeType, outputType){\n    let finalExamples = [];\n    if (examples){\n      for (let eg in examples){\n        let egJson=\"\";  \n            //TODO: in case the mimeType is XML then parse it as XML\n            //egJson = JSON.parse(examples[eg].value);\n            finalExamples.push({\n                \"exampleType\" : \"json\",\n                \"exampleValue\": outputType===\"text\"?JSON.stringify(examples[eg].value,undefined,2):examples[eg].value\n            });\n        } \n    }\n    else if (example){\n        //TODO: in case the mimeType is XML then parse it as XML\n        finalExamples.push({\n            \"exampleType\" : \"json\",\n            \"exampleValue\": outputType===\"text\"?JSON.stringify(example,undefined,2):example\n        });\n    }\n\n    if (finalExamples.length==0 ){\n      // If schema examples are not provided then generate one from Schema (only JSON fomat)\n      if (schema){\n        //TODO: in case the mimeType is XML then parse it as XML\n        let egJson = schemaToObj(schema,{}, {includeReadOnly:true, includeWriteOnly:true, deprecated:true});\n        finalExamples.push({\n            \"exampleType\" : \"json\",\n            \"exampleValue\": outputType===\"text\"?JSON.stringify(egJson,undefined,2):egJson\n        });\n      }\n      else{\n        // No Example or Schema provided   \n        finalExamples.push({\n            \"exampleType\" : \"text\",\n            \"exampleValue\": \"\" \n        });\n      }\n    }\n    return finalExamples;\n}\n\n/* For changing JSON-Schema to a Sample Object, as per the schema */ \nfunction schemaToObj (schema, obj, config={}) {\n    if (schema==null){\n        return;\n    }\n    if (schema.type===\"object\" || schema.properties){\n        for( let key in schema.properties ){\n            if ( schema.properties[key].deprecated ) {\n                continue;\n            }\n            if ( schema.properties[key].readOnly && !config.includeReadOnly ) {\n                continue;\n            }\n            if ( schema.properties[key].writeOnly && !config.includeWriteOnly ) {\n                continue;\n            }\n            //let temp = Object.assign({}, schema.properties[key] );\n            obj[key] = schemaToObj(schema.properties[key],{}, config);\n        }\n    }\n    else if (schema.type===\"array\" || schema.items ){\n        //let temp = Object.assign({}, schema.items );\n        obj = [schemaToObj(schema.items,{}, config)  ]\n    }\n    else if (schema.allOf ){\n\n        if (schema.allOf.length===1){\n            if (!schema.allOf[0]){\n                return \"string\";\n            }\n            else{\n                return getSampleValueByType(schema.allOf[0]);\n            }\n        }\n        let objWithAllProps = {};\n        schema.allOf.map(function(v){\n            if (v && v.type){\n                let partialObj = schemaToObj(v,{}, config);\n                Object.assign(objWithAllProps, partialObj);\n            }\n        });\n        obj = objWithAllProps;\n    }\n    else{\n        return getSampleValueByType(schema);\n    }\n    return obj;\n}\n\nfunction getSampleValueByType(schemaObj) {\n    if (schemaObj.example) {\n      return schemaObj.example;\n    }\n\n    if (Object.keys(schemaObj).length === 0) {\n        return null;\n    }\n\n    const typeValue = schemaObj.format || schemaObj.type || (schemaObj.enum ? 'enum' : null);\n    switch (typeValue) {\n        case 'int32':\n        case 'int64':\n        case 'integer':\n            return 0;\n        case 'float':\n        case 'double':\n        case 'number':\n            return 0.5;\n        case 'string':\n            return (schemaObj.enum ? schemaObj.enum[0] : (schemaObj.pattern ? schemaObj.pattern : \"string\"))\n        case 'byte':\n            return btoa('string');\n        case 'binary':\n            return 'binary';\n        case 'boolean':\n            return false;\n        case 'date':\n            return (new Date(0)).toISOString().split('T')[0];\n        case 'date-time':\n            return (new Date(0)).toISOString();\n        case 'dateTime':\n            return (new Date(0)).toISOString();\n        case 'password':\n            return 'password';\n        case 'enum':\n            return schemaObj.enum[0];\n        case 'uri':\n            return 'http://example.com';\n        case 'uuid':\n            return '3fa85f64-5717-4562-b3fc-2c963f66afa6';\n        case 'email':\n            return 'user@example.com';\n        case 'hostname':\n            return 'example.com';\n        case 'ipv4':\n            return '198.51.100.42';\n        case 'ipv6':\n            return '2001:0db8:5b96:0000:0000:426f:8e17:642a';\n        case 'circular':\n            return 'CIRCULAR REF';\n        default:\n            if (schemaObj.nullable) {\n                return null;\n            }\n            else {\n                console.warn('Unknown schema value', schemaObj);\n                return '?';\n            }\n    }\n  }\n\nfunction schemaToElTree(schema, obj, name) {\n    if (schema.type===\"object\" || schema.properties){\n        for( let key in schema.properties ){\n            let temp = Object.assign({}, schema.properties[key] );\n            if (schema.properties[key].type===\"object\" || schema.properties[key].properties){\n                obj.push({\n                    \"label\": {label:key , type:schema.properties[key].type, descr:schema.properties[key].description},\n                    \"children\": schemaToElTree(temp, [], key)\n                });\n            }\n            else if (schema.properties[key].type===\"array\" || schema.properties[key].items){\n                let typeOfArr=\"\";\n                if (schema.properties[key].items.properties){\n                    typeOfArr = \"array of objects\";\n                }\n                else {\n                    typeOfArr = \"array of \" + schema.properties[key].items.type;\n                }\n                obj.push({\n                    \"label\"   : {label:\"[ \"+key+\" ]\", type:typeOfArr, descr:schema.properties[key].description},\n                    \"children\": schemaToElTree(temp, [], key)\n                });\n            }\n            else{\n                let typeOfField=\"\";\n                if (schema.properties[key].enum){\n                    typeOfField = \"Enum: \" + schema.properties[key].enum.join(\" | \");\n                }\n                else{\n                    typeOfField = schema.properties[key].type;\n                }\n                obj.push({\n                    \"label\": {label:key, type:typeOfField, descr:schema.properties[key].description},\n                });\n            }\n        }\n    }\n    else if (schema.type===\"array\"){\n        if (schema.items.type===\"object\" || schema.items.properties){\n            let temp = Object.assign({}, schema.items);\n            return schemaToElTree(temp, []);\n        }\n        else if (schema.items.type===\"array\"){\n            obj.push({\n                \"label\": {label:\"[ \"+schema.items.type+\" ]\", type:schema.items.type, descr:schema.items.description }\n            });\n        }\n        else{\n            return;\n            /*\n            obj.push({\n                \"label\": {label:\"[\"+schema.items.type+\" ]\", type:schema.items.type, descr:schema.items.description}\n            });\n            */\n        }\n    }\n    else{\n        obj.push({\n            \"label\" : {label:name, type:schema.type, descr:schema.description}\n        });\n    }\n    return obj;\n}\n\nfunction getBaseUrlFromUrl(url){\n    let pathArray = url.split( '/' );\n    return pathArray[0] + \"//\" + pathArray[2];\n}\n\nfunction removeCircularReferences(level=0) {\n    const seen = new WeakSet();\n    return (key, value) => {\n      if (typeof value === \"object\" && value !== null) {\n        if (seen.has(value)) {\n          //let dupVal = Object.assign({}, value);\n          //return;\n          if (level > 0){\n              return {};\n          }\n          else{\n            let dupVal = JSON.parse(JSON.stringify(value, removeCircularReferences(level+1)));\n            seen.add(dupVal);\n            return dupVal;\n          }\n          \n        }\n        seen.add(value);\n      }\n      return value;\n    };\n  };\n\n\nexport { debounce, schemaToModel, schemaToObj, schemaToElTree, generateExample, getTypeInfo, getBaseUrlFromUrl, removeCircularReferences }","import { LitElement, html } from 'lit-element';\nimport JsonTree from '@/components/json-tree'; \nimport SchemaTree from '@/components/schema-tree';  \nimport vars from '@/styles/vars';\nimport TableStyles from '@/styles/table-styles';\nimport FlexStyles from '@/styles/flex-styles';\nimport InputStyles from '@/styles/input-styles';\nimport FontStyles from '@/styles/font-styles';\nimport CommonStyles from '@/styles/common-styles';\nimport { schemaToModel, getTypeInfo, schemaToObj, generateExample, removeCircularReferences} from '@/utils/common-utils';\nimport marked from 'marked';\nimport {unsafeHTML} from 'lit-html/directives/unsafe-html.js';\n\n\n// Create your custom component\nexport default class ApiRequest extends LitElement {\n  render() {\n    return html`\n    ${TableStyles}\n    ${InputStyles}\n    ${FontStyles}\n    ${FlexStyles}\n    ${CommonStyles}\n    <style>\n      .title{\n        font-family:${vars.font.regular};\n        font-size:${vars.font.titleSize};\n        font-weight:bold;\n        margin-bottom:16px;\n      }\n      .param-name,\n      .param-type{\n        margin: 1px 0;\n        text-align: right;\n        line-height: 12px;\n      }\n      .param-name{\n        color: var(--fg); \n        font-family: ${vars.font.mono};\n      }\n      .param-type{\n        color: var(--light-fg); \n        font-family: ${vars.font.regular};\n      }\n      .top-gap{margin-top:24px;}\n      .tab-buttons{\n        height:30px;\n        border-bottom: 1px solid var(--light-border-color) ;\n        align-items: stretch;\n      }\n      .tab-btn{\n        border:none;\n        background-color:transparent;\n        cursor:pointer;\n        border-bottom: 3px solid transparent;\n        outline:none;\n        font-size:12px;\n        margin-right:16px;\n      }\n      .tab-btn.active{\n        border-bottom: 3px solid var(--primary-color); \n        font-weight:bold;\n        color:var(--primary-color);\n      }\n\n      .tab-btn:hover{\n        color:var(--primary-color);\n      }\n      .tab-content{\n        margin:-1px 0 0 0;\n      }\n\n    </style>\n    <div class=\"col regular-font\">\n    <div class=\"title\">REQUEST</div>\n    ${this.inputParametersTemplate('path')}\n    ${this.inputParametersTemplate('query')}\n    ${this.inputParametersTemplate('formData')}\n    ${this.requestBodyTemplate()}\n    ${this.inputParametersTemplate('header')}\n    ${this.inputParametersTemplate('cookie')}\n    </div>\n    `\n  }\n\n  static get properties() {\n    return {\n      parameters  :{type: Array},\n      request_body:{type: Object}\n    };\n  }\n\n\n  inputParametersTemplate(paramType){\n    let title =\"\";\n    let filteredParams= this.parameters? this.parameters.filter(param => param.in === paramType):[];\n    if (filteredParams.length == 0 ){\n      return \"\";\n    }\n    if (paramType==='path'){ title = \"PATH PARAMETERS\"}\n    else if (paramType==='query'){ title = \"QUERY-STRING PARAMETERS\"}\n    else if (paramType==='header'){ title = \"REQUEST HEADERS\"}\n    else if (paramType==='formData'){ title = \"FORM DATA\"}\n    else if (paramType==='cookie'){ title = \"COOKIES\"}\n\n    return html`\n    <div class=\"table-title top-gap\">${title}</div>\n    <table style=\"width: 100%\" class=\"m-table\">\n      ${filteredParams.map(param => html`<tr> \n        <td style=\"min-width:80px\">\n          <div class=\"param-name\">\n            ${param.required?html`<span style='color:orangered'>*</span>`:``}${param.name}\n          </div>\n          <div class=\"param-type\">${unsafeHTML(getTypeInfo(param.schema))}</div>\n        </td>  \n        <td style=\"min-width:100px\">\n          <input type=\"text\" class=\"m-small\" style=\"width:100%\" value=\"${param.example?param[\"x-example\"]:''}\">\n        </td>\n        <td>\n          ${param.description?html`<span class=\"m-markdown\"> ${unsafeHTML(marked(param.description))} </span> `:``}\n        </td>  \n      </tr>`\n      )}\n    </table>`\n  }\n\n  requestBodyTemplate(){\n    if(!this.request_body){\n      return '';\n    }\n    if (Object.keys(this.request_body).length == 0){\n      return '';\n    }\n    \n    let mimeRequestTypes={};\n    let selectedMimeReqKey;\n    let mimeReqCount=0;\n\n    let content = this.request_body.content;\n    for(let mimeReq in content ) {\n      let exampleType=\"\"; // can be json, xml, plain\n      let mimeReqObj = content[mimeReq];\n      let reqSchemaTree=\"\", reqExample=\"\";\n      //Remove Circular references from RequestBody json-schema \n      try {\n          mimeReqObj.schema = JSON.parse(JSON.stringify(mimeReqObj.schema, removeCircularReferences()));\n      }\n      catch{\n          console.error(\"Unable to resolve circular refs in schema\", mimeReqObj.schema);\n          return;\n      }\n\n      // Generate the Schema Model  in Element UI tree format\n      // reqSchemaTree = schemaToElTree(mimeReqObj.schema, [] );\n      reqSchemaTree = schemaToModel(mimeReqObj.schema,{});\n      // Generate Example\n      reqExample = generateExample(mimeReqObj.examples, mimeReqObj.example, mimeReqObj.schema, mimeReq, \"text\");\n\n      mimeRequestTypes[mimeReq]={\n        \"examples\"   : reqExample,\n        \"schemaTree\" : reqSchemaTree\n      };\n      selectedMimeReqKey = mimeReq;\n      mimeReqCount++;\n    }\n    return html`\n    <div class=\"table-title top-gap\">BODY PARAMETERS</div>\n    <div class=\"row\" style=\"align-items:flex-end; padding:0 8px 2px 0;\">\n      <div class=\"m-text small gray\"> ${this.request_body.description} </div>\n    </div>\n    <div id=\"tab_panel\" class=\"tab-panel col\" style=\"border-width:0; min-height:200px\">\n      <div id=\"tab_buttons\" class=\"tab-buttons row\" @click=\"${this.activateTab}\">\n        <button class=\"tab-btn active\" content_id=\"content_a\"> Example </button>\n        <button class=\"tab-btn\" content_id=\"content_b\"> Model</button>\n      </div>\n      <div id=\"content_a\" class=\"tab-content col\" style=\"flex:1; \">\n        <textarea class=\"mono\" style=\"min-height:180px; padding:16px\">${mimeRequestTypes[selectedMimeReqKey].examples[0]?mimeRequestTypes[selectedMimeReqKey].examples[0].exampleValue:''}</textarea>\n      </div>\n      <div id=\"content_b\" class=\"tab-content col\" style=\"flex:1;display:none\">\n        <schema-tree class=\"border\" style=\"padding:16px;\" .data=\"${mimeRequestTypes[selectedMimeReqKey].schemaTree? mimeRequestTypes[selectedMimeReqKey].schemaTree:''}\"></schema-tree>\n      </div>\n    </div>\n\n\n    \n    `\n  }\n\n  activateTab(e){\n    if (e.target.classList.contains(\"active\")  || e.target.classList.contains(\"tab-btn\")===false){\n      return;\n    }\n    \n    let activeTabBtn = this.shadowRoot.querySelector('.tab-btn.active');\n    let clickedTabBtn = e.target;\n    activeTabBtn.classList.remove(\"active\");\n    e.target.classList.add(\"active\");\n    let showContentEl = this.shadowRoot.getElementById(clickedTabBtn.attributes.content_id.value);\n    let allContentEls = this.shadowRoot.querySelectorAll('.tab-content');\n    if (showContentEl){\n      showContentEl.style.display=\"flex\";\n      allContentEls.forEach(function(v){\n        if (v.attributes.id.value !== clickedTabBtn.attributes.content_id.value){\n          v.style.display=\"none\";\n        }\n      })\n    }\n\n\n\n    //console.log(e.target.classList);\n\n  }\n\n\n}\n// Register the element with the browser\ncustomElements.define('api-request', ApiRequest);\n","import { LitElement, html } from 'lit-element'; \nimport {schemaToModel, schemaToObj, generateExample, removeCircularReferences} from '@/utils/common-utils';\nimport vars from '@/styles/vars';\nimport FontStyles from '@/styles/font-styles';\nimport FlexStyles from '@/styles/flex-styles';\nimport TableStyles from '@/styles/table-styles';\nimport InputStyles from '@/styles/input-styles';\nimport SchemaTree from '@/components/schema-tree'; \n\n// Create your custom component\nexport default class ApiResponse extends LitElement {\n  render() {\n    return html`\n    ${FontStyles}\n    ${FlexStyles}\n    ${TableStyles}\n    ${InputStyles}\n    <style>\n      .title{\n        font-family:${vars.font.regular};\n        font-size:${vars.font.titleSize};\n        font-weight:bold;\n        margin-bottom:8px;\n      }\n      .resp-head{\n        vertical-align: middle;\n        padding:16px 0 8px;\n      }\n      .resp-head.divider{border-top: 1px solid var(--border-color);}\n      .resp-status{ \n        font-weight:bold;\n      }\n      .top-gap{margin-top:16px;}\n      .tab-buttons{\n        height:30px;\n        border-bottom: 1px solid var(--light-border-color) ;\n        align-items: stretch;\n      }\n      .tab-btn{\n        color:var(--fg);\n        border:none;\n        background-color:transparent;\n        cursor:pointer;\n        border-bottom: 3px solid transparent;\n        outline:none;\n        font-size:12px;\n        margin-right:16px;\n      }\n      .tab-btn.active{\n        border-bottom: 3px solid var(--primary-color);\n        font-weight:bold;\n        color:var(--primary-color);\n      }\n\n      .tab-btn:hover{\n        color:var(--primary-color);\n      }\n      .tab-content{\n        margin:-1px 0 0 0;\n      }\n    </style>\n    <div class=\"col regular-font\">\n    <div class=\"title\">RESPONSE</div>\n    ${this.responseTemplate()}\n    `\n\n  }\n\n  /*\n    ${this.mimeResponsesForEachStatus.map(\n      responsesByStatus => html`<end-point .path=${path}> </end-point>`\n    )}`\n    mimeResponsesForEachStatus\n    ${this.responseTemplate()}\n    <!-- schema-tree .data=\"${this.data}\"></schema-tree -->\n    </div>\n    `\n*/\n  static get properties() {\n    return {\n      responses:{type: Object}\n    };\n  }\n\n  responseTemplate(){\n\n    let selectedMimeValueForEachStatus={};\n    let headersForEachRespStatus={};\n    let selectedMimeValue=\"\";\n    let mimeResponsesForEachStatus={};\n    let mimeRespCountForEachStatus=0;\n\n    for(let statusCode in this.responses) {\n      let allMimeResp={};\n      let mimeRespCount=0;\n      for(let mimeResp in this.responses[statusCode].content ) {\n        let mimeRespObj = this.responses[statusCode].content[mimeResp];\n        //Remove Circular references from Response schema \n        try {\n            mimeRespObj.schema = JSON.parse(JSON.stringify(mimeRespObj.schema, removeCircularReferences(0)));\n        }\n        catch{\n            console.error(\"Unable to resolve circular refs in schema\", mimeRespObj.schema);\n            return;\n        }\n        \n        // Generate Schema\n        let schemaTree = schemaToModel(mimeRespObj.schema,{});\n        \n        // Generate Example\n        let respExample = generateExample(mimeRespObj.examples, mimeRespObj.example, mimeRespObj.schema, mimeResp, \"json\");\n        allMimeResp[mimeResp] = {\n          \"description\":this.responses[statusCode].description,\n          \"examples\"  : respExample,\n          \"schemaTree\": schemaTree,\n        }\n        selectedMimeValue = mimeResp;\n        selectedMimeValueForEachStatus[statusCode]= mimeResp;\n        mimeRespCount++;\n      }\n\n      // Headers for each response status\n      let tempHeaders=[];\n      for (let key in this.responses[statusCode].headers){\n        tempHeaders.push ( { \"name\":key, ...this.responses[statusCode].headers[key]} );\n      }\n      headersForEachRespStatus[statusCode] = tempHeaders;\n      mimeResponsesForEachStatus[statusCode] = allMimeResp;\n      //mimeRespCountForEachStatus[statusCode] = mimeRespCount;\n    }\n    return html`${Object.keys(this.responses).map(\n\n      (status, index)  => html`\n      <div class=\"resp-head ${index===0?'top-gap':'divider'}\">\n        <span class=\"resp-status\">${status}:</span> \n        <span class=\"resp-descr\">${this.responses[status].description}</span> \n      </div>      \n      ${Object.keys(mimeResponsesForEachStatus[status]).map(\n        mimeType => html`\n          <!-- TAB PANEL -->\n          <div id=\"${status}_${mimeType}_tab-panel\" @click=\"${this.activateTab}\" class=\"tab-panel col\" style=\"border-width:0; min-height:200px\">\n            <div id=\"${status}_${mimeType}_tab-buttons\" class=\"tab-buttons row\" >\n              <button class=\"tab-btn active\" content_id=\"${status}_${mimeType}_content_a\"> Example </button>\n              <button class=\"tab-btn\" content_id=\"${status}_${mimeType}_content_b\"> Model</button>\n              <div style=\"flex:1\"></div>\n              <div style=\"align-self:center;font-size:12px;\"> ${mimeType} </div>\n            </div>\n            <div id=\"${status}_${mimeType}_content_a\" class=\"tab-content col\" style=\"flex:1; \">\n              <json-tree class=\"border\" style=\"padding:16px;\" .data=\"${mimeResponsesForEachStatus[status][mimeType].examples[0].exampleValue}\"></json-tree>\n            </div>\n            <div id=\"${status}_${mimeType}_content_b\" class=\"tab-content col\" style=\"flex:1;display:none\">\n              <schema-tree class=\"border\" style=\"padding:16px;\" .data=\"${mimeResponsesForEachStatus[status][mimeType].schemaTree}\"></schema-tree>\n            </div>\n          </div>`\n      )}`\n    )}`\n  }\n\n  activateTab(e){\n    if (e.target.classList.contains(\"active\")  || e.target.classList.contains(\"tab-btn\")===false){\n      return;\n    }\n    let activeTabBtn  = e.currentTarget.querySelector(\":scope .tab-btn.active\");\n    activeTabBtn.classList.remove(\"active\");\n    e.target.classList.add(\"active\");\n    let showContentElsId = e.target.attributes.content_id.value;\n    let allContentEls = e.currentTarget.querySelectorAll(':scope > .tab-content');\n    if (showContentElsId){\n      allContentEls.forEach(function(v){\n        v.style.display =  v.attributes.id.value === showContentElsId?\"flex\":\"none\";\n      })\n    }\n  }\n\n\n}\n// Register the element with the browser\ncustomElements.define('api-response', ApiResponse);\n","import { LitElement, html } from 'lit-element'; \nimport vars from '@/styles/vars';\nimport {unsafeHTML} from 'lit-html/directives/unsafe-html.js';\nimport marked from 'marked';\nimport ApiRequest from '@/components/api-request'; \nimport ApiResponse from '@/components/api-response'; \nimport FontStyles from '@/styles/font-styles';\n\n// Create your custom component\nexport default class EndPoint extends LitElement {\n  render() {\n    return html`\n     ${FontStyles}\n    <style>\n      .m-endpoint.expanded{\n        margin-bottom:16px; \n      }\n      .m-endpoint > .head{\n        border-width:1px 1px 1px 5px;\n        border-style:solid;\n        border-color:transparent;\n        border-top-color:var(--light-border-color);\n        display:flex;\n        padding:6px 16px;\n        align-items: baseline;\n        cursor: pointer;\n      }\n      .m-endpoint > .head.put:hover,\n      .m-endpoint > .head.put.expanded{\n        border-color:var(--put-color); \n        background-color:var(--light-put-color); \n      }\n      .m-endpoint > .head.post:hover,\n      .m-endpoint > .head.post.expanded{\n        border-color:var(--post-color); \n        background-color:var(--light-post-color); \n      }\n      .m-endpoint > .head.get:hover,\n      .m-endpoint > .head.get.expanded{\n        border-color:var(--get-color); \n        background-color:var(--light-get-color); \n      }\n      .m-endpoint > .head.delete:hover,\n      .m-endpoint > .head.delete.expanded{\n        border-color:var(--delete-color); \n        background-color:var(--light-delete-color); \n      }\n      .m-endpoint > .head.patch:hover,\n      .m-endpoint > .head.patch.expanded{\n        border: 1px solid var(--patch-color); \n        background-color:var(--light-patch-color); \n      }\n      .m-endpoint .body {\n        flex-wrap:wrap;\n        padding:16px 0px 0 0px;\n        border-width:0px 1px 1px 5px;\n        border-style:solid;\n        box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15);\n      }\n      .m-endpoint .body.delete{ border-color:var(--delete-color); }\n      .m-endpoint .body.patch{ border-color:var(--patch-color); }\n      .m-endpoint .body.put{ border-color:var(--put-color); }\n      .m-endpoint .body.post{border-color:var(--post-color);}\n      .m-endpoint .body.get{ border-color:var(--get-color); }\n\n      .head .path{\n        display: inline-block;\n        font-family: monospace;\n        align-items: center;\n        word-wrap: break-word;\n        min-width:400px;\n      }\n\n      .head .descr{\n        font-size: 12px;\n        color:var(--light-fg);\n        font-weight:400;\n        overflow: hidden;\n        display: inline-block;\n        align-items: center;\n\n      }\n\n      .body .summary{\n        padding:8px 24px;\n      }\n      .body .summary .title{\n        font-size:20px;\n        margin-bottom: 6px;\n        white-space:nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n      .head .depricated{\n        text-decoration: line-through red;\n      }\n\n      .method{\n        padding:2px 5px;\n        vertical-align: middle;\n        height: 20px;\n        line-height: 20px;\n        min-width: 48px;\n        border-radius: 2px;\n        display:inline-block;\n        font-size:12px;\n        text-align: center;\n        font-weight: bold;\n        text-transform:uppercase;\n        margin-right:5px;\n      }\n      .method.delete{ border: 2px solid var(--delete-color);}\n      .method.patch{ border: 2px solid var(--patch-color); }\n      .method.put{ border: 2px solid var(--put-color); }\n      .method.post{ border: 2px solid var(--post-color); }\n      .method.get{ border: 2px solid var(--get-color); }\n\n      .req-resp-container{\n        display: flex;\n        margin-top:16px;\n        align-items: stretch;\n        flex-wrap: wrap;\n        flex-direction: var(--layout, row);\n        border-top:1px solid var(--light-border-color);\n      }\n      .request,\n      .response{\n        flex:1; \n        min-height:100px;\n        padding:16px 24px;\n        overflow:hidden;\n      }\n      ${this.layout==='row'?\n      html`\n      .patch .request{ border-right: 1px solid var(--patch-color); }\n      .put .request{ border-right: 1px solid var(--put-color); }\n      .post .request{ border-right: 1px solid var(--post-color); }\n      .get .request{ border-right: 1px solid var(--get-color); }\n      .delete .request{ border-right: 1px solid var(--delete-color); }\n      `:\n      html`\n      .patch .request{ border-bottom: 1px dashed var(--patch-color); }\n      .put .request{ border-bottom: 1px dashed var(--put-color); }\n      .post .request{ border-bottom: 1px dashed var(--post-color); }\n      .get .request{ border-bottom: 1px dashed var(--get-color); }\n      .delete .request{ border-bottom: 1px dashed var(--delete-color); }\n      `\n      }\n\n    </style>\n      \n    <div  class='m-endpoint regular-font ${this.path.method} ${this.path.expanded?'expanded':'collapsed'}'>\n      \n      <!-- Endpoint Head -->\n      <div @click=\"${this.toggleExpand}\" class='head ${this.path.method} ${this.path.expanded?'expanded':'collapsed'}'>\n        <div class=\"method ${this.path.method}\" > ${this.path.method} </div> \n        <div class=\"path ${this.path.depricated?'depricated':''}\"> ${this.path.path} </div>\n          ${this.path.depricated?html`<span style=\"font-size:12px; text-transform:uppercase; font-weight:bold; color:orangered; margin:2px 0 0 5px;\"> Depricated </span>`:''}\n        <div style=\"min-width:60px; flex:1\"></div>\n        <div class=\"descr\"> ${this.path.summary} </div>\n      </div>\n      \n      <!-- Endpoint Body -->\n      ${this.path.expanded?html`\n      <div class='body ${this.path.method}'>\n        ${this.path.summary || this.path.description?html`\n          <div class=\"summary\">\n            <div class=\"title\">${this.path.summary}</div>\n            ${this.path.summary !== this.path.description?html`\n              <div class=\"m-markdown\"> \n                ${unsafeHTML(marked(this.path.description?this.path.description:''))}\n              </div>`\n            :''}  \n          </div>`\n        :``}\n        <div class='req-resp-container'> \n          <api-request  class=\"request\"  .parameters=\"${this.path.parameters}\" .request_body=\"${this.path.requestBody}\"  ></api-request>\n          <api-response class=\"response\" .responses=\"${this.path.responses}\"></api-response>\n        </div>\n      </div>`\n    :``}\n\n    </div>`\n  }\n\n  static get properties() {\n    return {\n      path:{type:Object},\n      layout:{type:String}\n    };\n  }\n\n  toggleExpand(){\n    this.path.expanded = !this.path.expanded;\n    console.log(this.path);\n    this.requestUpdate();\n  }\n}\n// Register the element with the browser\ncustomElements.define('end-point', EndPoint);\n","import { LitElement, html } from 'lit-element'; \nimport EndPoint from '@/components/end-point'; \n// Create your custom component\nexport default class EndPoints extends LitElement {\n  render() {\n    return html`\n    ${this.paths.map(\n      path => html`<end-point .path=${path} layout=\"${this.layout?this.layout:'row'}\"> </end-point>`\n    )}`\n  }\n\n  static get properties() {\n    return {\n      paths:{type: Object},\n      layout: {type: String}\n    };\n  }\n}\n// Register the element with the browser\ncustomElements.define('end-points', EndPoints);\n","import { LitElement, html, css} from 'lit-element'; \nimport {unsafeHTML} from 'lit-html/directives/unsafe-html.js';\nimport MLogo from '@/components/m-logo'; \nimport EndPoints from '@/components/end-points'; \nimport FontStyles from '@/styles/font-styles';\nimport InputStyles from '@/styles/input-styles';\nimport CommonStyles from '@/styles/common-styles';\nimport FlexStyles from '@/styles/flex-styles';\n\nimport vars from '@/styles/vars';\nimport ProcessSpec from '@/utils/parse-utils';\nimport marked from 'marked';\nimport clonedeep from 'lodash.clonedeep';\nimport debounce  from 'lodash.debounce';\n\nclass RapiDoc extends LitElement {\n\n  render() {\n    return html`\n      ${FontStyles}\n      ${InputStyles}\n      ${FlexStyles}\n      ${this.theme==='dark'?\n      html`<style>\n        :host{\n          --bg:#333;\n          --fg:#bbb;\n          --light-fg:#777;\n          --very-light-fg:#666;\n          --pre-border-color:#666;\n          --pre-fg:#fff;\n          --pre-bg:#222;\n          --code-fg:#ccc;\n          --code-bg:transparent;\n          --border-color:#666;\n          --input-bg:#303030;\n          --input-border-color:#297aa2;\n          --placeholder-color:#666;\n          --light-border-color:#444;\n          --light-get-color:#2a2a2a;\n          --light-put-color:#2a2a2a;\n          --light-post-color:#2a2a2a;\n          --light-delete-color:#2a2a2a;\n          --light-patch-color:#2a2a2a;\n          --hover-color:#2a2a2a;\n        }\n      </style>`\n      :html`<style>\n        :host{\n          --bg:#fff;\n          --fg:#333;\n          --light-fg:#999;\n          --very-light-fg:#bbb;\n          --pre-border-color:#000;\n          --pre-fg:#ccc;\n          --pre-bg:#263238;\n          --code-fg:#ccc;\n          --code-bg:transparent;\n          --border-color:#ccc;\n          --input-bg:#fff;\n          --input-border-color:#C5D9E8;\n          --placeholder-color:#666;\n          --light-border-color:#eee;\n          --light-get-color:#eff8fd;\n          --light-put-color:#fff5e6;\n          --light-post-color:#fbfff0;\n          --light-delete-color:#fff0f0;\n          --light-patch-color:#fff5cc;\n          --hover-color:#f7f7f7;\n        }\n      </style>`\n      }\n      ${html`<style>\n        :host{\n          --hover-bg:#f7f7f7;\n          --get-color:#47AFE8;\n          --put-color:#FF9900;\n          --post-color:#99CC00;\n          --delete-color:#F06560;\n          --patch-color:#fc0;\n          --link-color:#47AFE8;\n          --primary-color:${this.primaryColor?html`${this.primaryColor}`:`#FF791A`};\n          --dark-primary-color:${vars.color.brightness(this.primaryColor?this.primaryColor:'#FF791A', -30)};\n          --primary-text:${this.primaryColor?html`${vars.color.invert(this.primaryColor)}`:`#ffffff`};\n          --header-bg:${this.headerColor?html`${this.headerColor}`:`#444`};\n          --header-fg:${this.headerColor?html`${vars.color.invert(this.headerColor)}`:`#ccc`};\n          --layout:${this.layout?html`${this.layout}`:`row`}\n        }\n      </style>`} \n      \n      <style>\n        :host{\n          display:block;\n          min-width:750px;\n          color:var(--fg);\n          background-color:var(--bg);\n          font-family:${vars.font.regular};\n        }\n        .header{\n          background-color:var(--header-bg);\n          color:var(--header-fg);\n        }\n        .header .title{\n          font-size:24px;\n        }\n        input.header-input{\n          background:${this.headerColor?vars.color.brightness(this.headerColor, -20):vars.color.inputReverseBg};\n          color:var(--header-fg);\n          border:1px solid var(--dark-primary-color); \n        }\n        .tag{\n          font-size: 18px;\n          color:var(--fg);\n          padding: 28px 0px 4px 20px;\n          text-transform: uppercase;\n        }\n        .doc-info{\n          padding:16px 20px;\n        }\n        .doc-info .title{\n          font-size:32px;\n        }\n\n      </style>\n\n      ${this.showHeader==='false'?'':html`\n      <div class=\"row header regular-font\" style=\"padding:8px 4px 8px 4px;min-height:48px\">\n        <div style=\"display:flex; align-items: center;\">\n          <m-logo style=\"height:36px;width:36px;margin-left:5px\"></m-logo>\n          <div class=\"title\">${this.headingText}</div>\n        </div>  \n        <div style=\"margin: 0px 8px;display:flex\">\n          <input id=\"spec-url\" type=\"text\" class=\"header-input\" style=\"border-radius: 2px 0 0 2px;\" placeholder=\"Spec URL\" value=\"${this.specUrl}\" @change=\"${this.onSepcUrlChange}\">\n        </div>\n        <div style=\"flex:1\"></div>  \n        <div style=\"display:flex; flex-direction:column; margin-right:8px; align-items:flex-end;\">\n          <input class=\"header-input\" style=\"width:100px;\" type=\"text\" placeholder=\"Search\" @keyup=\"${debounce(this.onSearch, 200)}\">\n        </div> \n      </div>`}\n\n      ${this.showInfo==='false' || !this.resolvedSpec || !this.resolvedSpec.info?'':html`\n        <div class=\"doc-info\">\n          <div class=\"title\">\n            ${this.resolvedSpec.info.title}\n            ${!this.resolvedSpec.info.version?\"\":html`\n              <span style=\"font-size:14px;font-weight:bold\">\n                ${this.resolvedSpec.info.version}\n              </span>`\n            }\n          </div>\n          ${this.resolvedSpec.info.description?html`\n            ${unsafeHTML(`<div class='m-markdown regular-font'>${marked(this.resolvedSpec.info.description)}</div>`)}\n          `\n          :``}\n        </div>  \n      `}\n\n      ${this.resolvedSpec && this.resolvedSpec.tags ?html`<div id=\"searchInput\" style=\"margin:0 ${this.bodyPadding==='false'?'0':'16px'} \">\n        ${this.resolvedSpec.tags.map(tag => html`\n          <div class=\"tag regular-font\">${tag.name}</div>\n          <div style=\"margin:4px 20px\">\n            ${unsafeHTML(`<div class='m-markdown regular-font'>${marked(tag.description?tag.description:'')}</div>`)}\n          </div>\n          <end-points .paths=\"${tag.paths}\" layout=\"${this.layout?this.layout:'row'}\"></end-points>\n        `)}\n        </div>`\n      :''}\n    `}\n\n    static get properties() {\n      return {\n        specUrl: {\n          type: String, \n          attribute: 'spec-url',\n        },\n        headingText: {type: String, attribute: 'heading-text'},\n        headerColor: {type: String, attribute:  'header-color'},\n        primaryColor: {type: String, attribute: 'primary-color'},\n        layout: {type: String},\n        showHeader: {type: String, attribute: 'show-header'},\n        theme: {type: String},\n        bodyPadding: {type: String, attribute: 'body-padding'},\n        \n        logoUrl: {type: String, attribute: 'logo-url'},\n        showTry: {type: Boolean, attribute: 'show-try'},\n        showAuthentication: {type: Boolean, attribute: 'show-authentication'},\n        showInfo: {type: Boolean, attribute: 'show-info'},\n      };\n    }\n    attributeChangedCallback(name, oldVal, newVal) {\n      if (name=='spec-url'){\n        if (oldVal !== newVal){\n          this.loadSpec(newVal);\n        }\n      }\n      super.attributeChangedCallback(name, oldVal, newVal);\n    }\n\n    onOpenSpecClicked(e) {\n        this.setAttribute('spec-url', this.shadowRoot.getElementById('spec-url').value);\n    }\n\n    onSepcUrlChange(e){\n      if (this.specUrl){\n        this.setAttribute('spec-url', this.shadowRoot.getElementById('spec-url').value);\n      }\n    }\n\n    loadSpec(specUrl) {\n      var me = this;\n      if (!specUrl){\n        return;\n      }\n      ProcessSpec(specUrl).then(function(spec){\n        if (spec===undefined || spec === null){\n          console.error('Onoes! The API is invalid. ');\n        }\n        console.log(spec);\n        me.afterSpecParsedAndValidated(spec);\n      })\n      .catch(function(err) {\n        me.loading=false;\n        console.error('Onoes! The API is invalid. ' + err.message);\n      });\n    }\n\n    afterSpecParsedAndValidated(spec, isReloadingSpec=false){\n      this.resolvedSpec = clonedeep(spec); //spec;\n      this.resolvedSpecMaster = clonedeep(spec);\n      this.requestUpdate();\n    }\n\n    onFilter(){\n      this.resolvedSpec.tags[0].paths = this.resolvedSpec.tags[0].paths.slice(2);\n      this.requestUpdate();\n      console.log(\"filtered\");\n    }\n\n    onRestore(){\n      this.resolvedSpec.tags[0].paths = this.resolvedSpecMaster.tags[0].paths.slice(0);\n      this.requestUpdate();\n      console.log(\"restore\");\n      \n    }\n\n    onSearch(e){\n      debounce(function(){\n        console.log(\"Hello\", e.target.classList);\n      },200)\n    }\n}\n\ncustomElements.define('rapi-doc', RapiDoc);\n"],"mappings":"AACA;;;;;;;;;;;;;;ACgBA;;;;;;;;;;;;;;ACgBA;;;;;;;;;;;;;;ACiEA;;;;;;;;;;;;;;AC7EA;;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;ACKA;;;;;;;;;;;;;;ACLA;;;;;;;ACPA;;;;;;;;;;;;;ACwCA;;;;;;;;;;;;;;ACHA;;;;;;;;;;;;;;AC5BA;;;;;;;;;;;;;;ACGA;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;ACLA;;;;;;;;;;;;;;ACMA;;;;;;;;;;;;;;ACGA;;;;;;;;;;;;;;ACFA;;;;;;;;;ACqFA;;;ACjGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;AAKA;AAgBA;;AAEA;;AAIA;AAIA;;;AC7DA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;AAKA;AAmBA;AACA;;AAEA;AAEA;AACA;AAEA;;AAIA;AAIA;AACA;AAEA;AACA;;;;;;;;;;;;;ACvGA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;AAKA;;;;;;;;;;;;;;;;AAgBA;AACA;;;;;;ACvDA;;;;;;;;;;;;;ACAA;;;AAGA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;ACeA;ACRA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;AAYA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AACA;;AAKA;AAqBA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;;AAOA;;;AA0CA;;;AAGA;;;;;AAKA;;;AAGA;;;;;;AASA;AC/KA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAeA;AAuDA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAOA;AClJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwHA;;;;;;AAQA;;;;;;;;;;AAWA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AAEA;;AAEA;AACA;;AAGA;AACA;AAIA;ACnLA;ACaA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;AAmBA;;;;AAIA;;;AAGA;;;;AAIA;;;;AAIA;;;AAGA;AACA;;AAEA;AAFA;;AAMA;AACA;AAEA;;AAbA;AACA;AAgBA;AACA;AACA;;AAEA;;AAEA;;AAGA;AAGA","sourceRoot":""}